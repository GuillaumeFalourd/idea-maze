diff --git a/chrome/browser/devtools/devtools_window.cc b/chrome/browser/devtools/devtools_window.cc
index c65d151cf1..c28d798da6 100644
--- a/chrome/browser/devtools/devtools_window.cc
+++ b/chrome/browser/devtools/devtools_window.cc
@@ -3,6 +3,7 @@
 // found in the LICENSE file.

 #include "chrome/browser/devtools/devtools_window.h"
+#include "net/cert/x509_certificate.h"

 #include <algorithm>
 #include <memory>
@@ -395,9 +396,9 @@ class DevToolsWindow::Throttle : public content::NavigationThrottle {
 class DevToolsWindow::OwnedMainWebContents {
  public:
   explicit OwnedMainWebContents(
-      std::unique_ptr<content::WebContents> web_contents)
-      : keep_alive_(KeepAliveOrigin::DEVTOOLS_WINDOW,
-                    KeepAliveRestartOption::DISABLED),
+                  std::unique_ptr<content::WebContents> web_contents, bool headless = false)
+      : /* keep_alive_(KeepAliveOrigin::DEVTOOLS_WINDOW,
+           KeepAliveRestartOption::DISABLED), */
         web_contents_(std::move(web_contents)) {
     Profile* profile = GetProfileForDevToolsWindow(web_contents_.get());
     DCHECK(profile);
@@ -405,6 +406,11 @@ class DevToolsWindow::OwnedMainWebContents {
       // ScopedProfileKeepAlive does not support OTR profiles.
       profile_keep_alive_ = std::make_unique<ScopedProfileKeepAlive>(
           profile, ProfileKeepAliveOrigin::kDevToolsWindow);
+    if (!headless) //NWJS#7588: deadlock; in this NW feature, browser
+                   //quit/zero keepalive count
+                   //triggers destruction of DevToolsWindow
+      keep_alive_ = std::make_unique<ScopedKeepAlive>(KeepAliveOrigin::DEVTOOLS_WINDOW,
+                                                      KeepAliveRestartOption::DISABLED);
     }
   }

@@ -414,7 +420,7 @@ class DevToolsWindow::OwnedMainWebContents {
   }

  private:
-  ScopedKeepAlive keep_alive_;
+  std::unique_ptr<ScopedKeepAlive> keep_alive_;
   std::unique_ptr<ScopedProfileKeepAlive> profile_keep_alive_;
   std::unique_ptr<content::WebContents> web_contents_;
 };
@@ -807,6 +813,8 @@ void DevToolsWindow::ToggleDevToolsWindow(

   // If window is docked and visible, we hide it on toggle. If window is
   // undocked, we show (activate) it.
+  if (window->headless_)
+    return;
   if (!window->is_docked_ || do_open)
     window->ScheduleShow(action);
   else
@@ -949,6 +957,8 @@ void DevToolsWindow::Show(const DevToolsToggleAction& action) {
   bool should_show_window =
       !browser_ || (action.type() != DevToolsToggleAction::kInspect);

+  should_show_window = should_show_window && !headless_;
+
   if (!browser_)
     CreateDevToolsBrowser();

@@ -1044,7 +1054,8 @@ DevToolsWindow::DevToolsWindow(FrontendType frontend_type,
                                std::unique_ptr<WebContents> main_web_contents,
                                DevToolsUIBindings* bindings,
                                WebContents* inspected_web_contents,
-                               bool can_dock)
+                               bool can_dock,
+                               bool headless)
     : frontend_type_(frontend_type),
       profile_(profile),
       main_web_contents_(main_web_contents.get()),
@@ -1053,18 +1064,25 @@ DevToolsWindow::DevToolsWindow(FrontendType frontend_type,
       browser_(nullptr),
       is_docked_(true),
       owned_main_web_contents_(
-          std::make_unique<OwnedMainWebContents>(std::move(main_web_contents))),
+        std::make_unique<OwnedMainWebContents>(std::move(main_web_contents), headless)),
       can_dock_(can_dock),
       close_on_detach_(true),
+      headless_(headless),
       // This initialization allows external front-end to work without changes.
       // We don't wait for docking call, but instead immediately show undocked.
       life_stage_(can_dock ? kNotLoaded : kIsDockedSet),
       action_on_load_(DevToolsToggleAction::NoOp()),
       intercepted_page_beforeunload_(false),
       ready_for_test_(false) {
+  // shouldn't own the web content in embedded cdt use case #6004
+  // or it will be double freed on quit
+  if (headless)
+    owned_main_web_contents_.release();
   // Set up delegate, so we get fully-functional window immediately.
   // It will not appear in UI though until |life_stage_ == kLoadCompleted|.
-  main_web_contents_->SetDelegate(this);
+  if (!headless) //NWJS#4709: keep delegate to web_view_guest so the
+                 //shortcut is handled there
+    main_web_contents_->SetDelegate(this);
   // Bindings take ownership over devtools as its delegate.
   bindings_->SetDelegate(this);
   // DevTools uses PageZoom::Zoom(), so main_web_contents_ requires a
@@ -1128,7 +1146,8 @@ DevToolsWindow* DevToolsWindow::Create(
     const std::string& settings,
     const std::string& panel,
     bool has_other_clients,
-    bool browser_connection) {
+    bool browser_connection,
+    content::WebContents* cdt_web_contents) {
   if (!AllowDevToolsFor(profile, inspected_web_contents))
     return nullptr;

@@ -1146,6 +1165,20 @@ DevToolsWindow* DevToolsWindow::Create(
   // Create WebContents with devtools.
   GURL url(GetDevToolsURL(profile, frontend_type, frontend_url, can_dock, panel,
                           has_other_clients, browser_connection));
+
+  if (cdt_web_contents) {
+    cdt_web_contents->GetController().LoadURL(
+      DecorateFrontendURL(url), content::Referrer(),
+      ui::PAGE_TRANSITION_AUTO_TOPLEVEL, std::string());
+    DevToolsUIBindings* bindings =
+      DevToolsUIBindings::ForWebContents(cdt_web_contents);
+    if (!bindings)
+      return nullptr;
+    std::unique_ptr<WebContents> cdt_contents(cdt_web_contents);
+    return new DevToolsWindow(frontend_type, profile, std::move(cdt_contents), bindings,
+                              inspected_web_contents, can_dock, true);
+  }
+
   std::unique_ptr<WebContents> main_web_contents =
       WebContents::Create(WebContents::CreateParams(profile));
   main_web_contents->GetController().LoadURL(
@@ -1322,7 +1355,8 @@ void DevToolsWindow::WebContentsCreated(WebContents* source_contents,
                                         int opener_render_frame_id,
                                         const std::string& frame_name,
                                         const GURL& target_url,
-                                        WebContents* new_contents) {
+                                        WebContents* new_contents,
+                                        const std::u16string& nw_window_manifest) {
   if (target_url.SchemeIs(content::kChromeDevToolsScheme) &&
       target_url.path().rfind("device_mode_emulation_frame.html") !=
           std::string::npos) {
@@ -1442,7 +1476,7 @@ bool DevToolsWindow::PreHandleGestureEvent(
 }

 void DevToolsWindow::ActivateWindow() {
-  if (life_stage_ != kLoadCompleted)
+  if (life_stage_ != kLoadCompleted || headless_)
     return;
   if (is_docked_ && GetInspectedBrowserWindow())
     main_web_contents_->Focus();
@@ -1597,7 +1631,7 @@ void DevToolsWindow::RenderProcessGone(bool crashed) {
   // Docked DevToolsWindow owns its main_web_contents_ and must delete it.
   // Undocked main_web_contents_ are owned and handled by browser.
   // see crbug.com/369932
-  if (is_docked_) {
+  if (is_docked_ && !headless_) {
     CloseContents(main_web_contents_);
   } else if (browser_ && crashed) {
     browser_->window()->Close();
@@ -1632,6 +1666,10 @@ void DevToolsWindow::ShowCertificateViewer(const std::string& cert_chain) {
   ::ShowCertificateViewer(inspected_contents, parent, cert.get());
 }

+void DevToolsWindow::Close() {
+  browser_->window()->Close();
+}
+
 void DevToolsWindow::OnLoadCompleted() {
   // First seed inspected tab id for extension APIs.
   WebContents* inspected_web_contents = GetInspectedWebContents();
