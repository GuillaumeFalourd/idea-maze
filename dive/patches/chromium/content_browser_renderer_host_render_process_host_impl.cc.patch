diff --git a/content/browser/renderer_host/render_process_host_impl.cc b/content/browser/renderer_host/render_process_host_impl.cc
index 18ad9b07e8..e8d7853f6e 100644
--- a/content/browser/renderer_host/render_process_host_impl.cc
+++ b/content/browser/renderer_host/render_process_host_impl.cc
@@ -118,6 +118,7 @@
 #include "content/browser/renderer_host/render_process_host_impl.h"
 #include "content/browser/renderer_host/render_widget_helper.h"
 #include "content/browser/renderer_host/renderer_sandboxed_process_launcher_delegate.h"
+#include "content/browser/resolve_proxy_helper.h"
 #include "content/browser/service_worker/service_worker_context_wrapper.h"
 #include "content/browser/site_info.h"
 #include "content/browser/site_instance_impl.h"
@@ -277,6 +278,15 @@
 #define MAYBEVLOG DVLOG
 #endif

+#include "content/nw/src/common/shell_switches.h"
+#include "content/nw/src/browser/nw_content_browser_hooks.h"
+
+namespace nw {
+typedef bool (*RphGuestFilterURLHookFn)(content::RenderProcessHost* rph, const GURL* url);
+CONTENT_EXPORT RphGuestFilterURLHookFn gRphGuestFilterURLHook = nullptr;
+void LoadNodeSymbols();
+}
+
 namespace content {

 namespace {
@@ -294,6 +304,8 @@ RendererMainThreadFactoryFunction g_renderer_main_thread_factory = nullptr;
 base::Thread* g_in_process_thread = nullptr;

 RenderProcessHostFactory* g_render_process_host_factory_ = nullptr;
+RenderProcessHostImpl* g_main_host = nullptr;
+
 const char kSiteProcessMapKeyName[] = "content_site_process_map";

 RenderProcessHost::AnalyzeHungRendererFunction g_analyze_hung_renderer =
@@ -1506,6 +1518,7 @@ RenderProcessHostImpl::RenderProcessHostImpl(
                     ChromeTrackEvent::kRenderProcessHost, *this);

   widget_helper_ = new RenderWidgetHelper();
+  resolve_proxy_helper_ = new ResolveProxyHelper(GetID());

   ChildProcessSecurityPolicyImpl::GetInstance()->Add(GetID(), browser_context);

@@ -1717,6 +1730,8 @@ bool RenderProcessHostImpl::Init() {
       storage_partition_impl_->cors_exempt_header_list());

   if (run_renderer_in_process()) {
+    base::ThreadRestrictions::ScopedAllowIO allow_io;
+    nw::LoadNodeSymbols();
     DCHECK(g_renderer_main_thread_factory);
     // Crank up a thread and run the initialization there.  With the way that
     // messages flow between the browser and renderer, this thread is required
@@ -1738,6 +1753,8 @@ bool RenderProcessHostImpl::Init() {
     // in-process plugins.
     options.message_pump_type = base::MessagePumpType::DEFAULT;
 #endif
+    options.message_pump_type = base::MessagePumpType::NODE;
+
     // As for execution sequence, this callback should have no any dependency
     // on starting in-process-render-thread.
     // So put it here to trigger ChannelMojo initialization earlier to enable
@@ -3172,6 +3189,18 @@ void RenderProcessHostImpl::AppendRendererCommandLine(
     command_line->AppendSwitchASCII(blink::switches::kJavaScriptFlags,
                                     "--jitless");

+  bool allow_nw = false;
+  if (IsForGuestsOnly()) {
+    if (nw::GetInWebViewApplyAttr(&allow_nw) && allow_nw)
+      command_line->AppendSwitch("nwjs-guest-nw");
+    else
+      command_line->AppendSwitch("nwjs-guest");
+  }
+
+  if (nw::MixedContext()) {
+    command_line->AppendSwitch("mixed-context");
+  }
+
 #if BUILDFLAG(IS_WIN)
   command_line->AppendSwitchASCII(
       switches::kDeviceScaleFactor,
@@ -3198,6 +3227,7 @@ void RenderProcessHostImpl::PropagateBrowserCommandLineToRenderer(
   // Propagate the following switches to the renderer command line (along
   // with any associated values) if present in the browser command line.
   static const char* const kSwitchNames[] = {
+    "nwjs-test-mode",
     switches::kDisableInProcessStackTraces,
     sandbox::policy::switches::kDisableSeccompFilterSandbox,
     sandbox::policy::switches::kNoSandbox,
@@ -3209,6 +3239,9 @@ void RenderProcessHostImpl::PropagateBrowserCommandLineToRenderer(
     // Allow this to be set when invoking the browser and relayed along.
     sandbox::policy::switches::kEnableSandboxLogging,
 #endif
+    switches::kDisableRAFThrottling,
+    switches::kEnableNodeWorker,
+    switches::kEnableSpellChecking,
     switches::kAllowLoopbackInPeerConnection,
     switches::kAndroidFontsPath,
     switches::kAudioBufferSize,
@@ -4048,6 +4081,16 @@ void RenderProcessHostImpl::RegisterHost(int host_id, RenderProcessHost* host) {
   GetAllHosts().AddWithID(host, host_id);
 }

+void RenderProcessHostImpl::set_main_host() {
+  g_main_host = this;
+}
+
+RenderProcessHostImpl* RenderProcessHostImpl::main_host() {
+  return g_main_host;
+}
+
+extern bool g_browser_main_loop_shutting_down;
+
 // static
 void RenderProcessHostImpl::UnregisterHost(int host_id) {
   RenderProcessHost* host = GetAllHosts().Lookup(host_id);
@@ -4069,6 +4112,12 @@ void RenderProcessHostImpl::UnregisterHost(int host_id) {
                           host->GetBrowserContext()->GetUserData(
                               kCommittedSiteProcessCountTrackerKey)));

+  if (g_main_host == host)
+    g_main_host = nullptr;
+
+  if (run_renderer_in_process() && g_browser_main_loop_shutting_down)
+    return; //or the following line will crash because browser context
+            //has been destroyed
   // Look up the map of site to process for the given browser_context,
   // in case we need to remove this process from it.  It will be registered
   // under any sites it rendered that use process-per-site mode.
@@ -4121,6 +4170,8 @@ void RenderProcessHostImpl::FilterURL(RenderProcessHost* rph,
     TRACE_EVENT2("navigation",
                  "RenderProcessHost::FilterURL - failed CanRequestURL",
                  "process_id", rph->GetID(), "url", url->spec());
+    if (nw::gRphGuestFilterURLHook && nw::gRphGuestFilterURLHook(rph, url))
+      return;
     VLOG(1) << "Blocked URL " << url->spec();
     *url = GURL(kBlockedURL);
   }
@@ -4370,8 +4421,11 @@ RenderProcessHost* RenderProcessHostImpl::GetExistingProcessHost(
                                       .spare_render_process_host()) {
       continue;
     }
-    if (MayReuseAndIsSuitable(iter.GetCurrentValue(), site_instance))
+    if (MayReuseAndIsSuitable(iter.GetCurrentValue(), site_instance)) {
+      if (iter.GetCurrentValue() == g_main_host)
+        return g_main_host;
       suitable_renderers.push_back(iter.GetCurrentValue());
+    }
   }

   MAYBEVLOG(4) << __func__ << ": Found " << suitable_renderers.size()
@@ -4380,9 +4434,12 @@ RenderProcessHost* RenderProcessHostImpl::GetExistingProcessHost(

   // Now pick a random suitable renderer, if we have any.
   if (!suitable_renderers.empty()) {
-    int suitable_count = static_cast<int>(suitable_renderers.size());
-    int random_index = base::RandInt(0, suitable_count - 1);
-    return suitable_renderers[random_index];
+    //int suitable_count = static_cast<int>(suitable_renderers.size());
+    //int random_index = base::RandInt(0, suitable_count - 1);
+    //return suitable_renderers[random_index];
+    //NWJS: reuse first renderer, the main process for valid nw.Window.open
+    //callback value. see also app_window_api.cc:416
+    return suitable_renderers[0];
   }

   return nullptr;
@@ -4427,6 +4484,11 @@ void RenderProcessHostImpl::RegisterSoleProcessHostForSite(
   // use process-per-site mode.  We cannot check whether the process has
   // appropriate bindings here, because the bindings have not yet been
   // granted.
+  // don't register process when we're opening new_instance window, or
+  // the map slot will be took over and following same-instance window
+  // opening will return null; NWJS#4691
+  if (!nw::PinningRenderer())
+    return;
   if (!site_instance->GetSiteInfo().is_empty())
     map->RegisterProcess(site_instance->GetSiteInfo(), process);
 }
@@ -4778,6 +4840,12 @@ void RenderProcessHostImpl::RecordUserMetricsAction(const std::string& action) {
   base::RecordComputedAction(action);
 }

+void RenderProcessHostImpl::ResolveProxy(
+    const GURL& url,
+    mojom::RendererHost::ResolveProxyCallback callback) {
+  resolve_proxy_helper_->ResolveProxy(url, std::move(callback));
+}
+
 void RenderProcessHostImpl::UpdateProcessPriorityInputs() {
   int32_t new_visible_widgets_count = 0;
   unsigned int new_frame_depth = kMaxFrameDepthForPriority;
