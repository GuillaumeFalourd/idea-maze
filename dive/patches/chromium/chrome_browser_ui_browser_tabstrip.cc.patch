diff --git a/chrome/browser/ui/browser_tabstrip.cc b/chrome/browser/ui/browser_tabstrip.cc
index 0b377aacbf..aef9bcbfc7 100644
--- a/chrome/browser/ui/browser_tabstrip.cc
+++ b/chrome/browser/ui/browser_tabstrip.cc
@@ -4,6 +4,12 @@

 #include "chrome/browser/ui/browser_tabstrip.h"

+#include "base/json/json_reader.h"
+#include "extensions/common/extension_messages.h"
+#include "extensions/browser/app_window/app_window.h"
+#include "content/nw/src/nw_content.h"
+#include "content/nw/src/nw_base.h"
+
 #include "base/command_line.h"
 #include "base/feature_list.h"
 #include "chrome/browser/profiles/profile.h"
@@ -64,18 +70,51 @@ void AddWebContents(Browser* browser,
                     const GURL& target_url,
                     WindowOpenDisposition disposition,
                     const gfx::Rect& initial_rect,
-                    NavigateParams::WindowAction window_action) {
+                    NavigateParams::WindowAction window_action,
+		    std::string manifest) {
   // No code for this yet.
   DCHECK(disposition != WindowOpenDisposition::SAVE_TO_DISK);
   // Can't create a new contents for the current tab - invalid case.
   DCHECK(disposition != WindowOpenDisposition::CURRENT_TAB);

+  gfx::Rect rect = initial_rect;
+  int height = 0; int width = 0;
+  int x = 0; int y = 0;
+  bool has_frame = true;
+  bool fullscreen = false;
+  if (!manifest.empty()) {
+    std::unique_ptr<base::Value> val = base::JSONReader::ReadDeprecated(manifest);
+    if (val && val->is_dict()) {
+      std::unique_ptr<base::DictionaryValue> mnfst;
+      mnfst.reset(static_cast<base::DictionaryValue*>(val.release()));
+      if (mnfst->GetInteger("width", &width))
+        rect.set_width(width);
+      if (mnfst->GetInteger("height", &height))
+        rect.set_height(height);
+      if (mnfst->GetInteger("x", &x))
+        rect.set_x(x);
+      if (mnfst->GetInteger("y", &y))
+        rect.set_y(y);
+      has_frame = mnfst->FindBoolKey("frame").value_or(true);
+      fullscreen = mnfst->FindBoolKey("fullscreen").value_or(false);
+    }
+  }
+  extensions::AppWindow::CreateParams params0;
+  std::string js_doc_start, js_doc_end;
+  nw::CalcNewWinParams(new_contents.get(), &params0, &js_doc_start, &js_doc_end, manifest);
+  new_contents->GetMutableRendererPrefs()->
+    nw_inject_js_doc_start = js_doc_start;
+  new_contents->GetMutableRendererPrefs()->
+    nw_inject_js_doc_end = js_doc_end;
+  new_contents->SyncRendererPrefs();
+
   NavigateParams params(browser, std::move(new_contents));
   params.source_contents = source_contents;
   params.url = target_url;
   params.disposition = disposition;
-  params.window_bounds = initial_rect;
-  params.window_action = window_action;
+  params.window_bounds = rect;
+  params.window_action = fullscreen ? NavigateParams::SHOW_WINDOW_FULLSCREEN : window_action;
+  params.frameless = !has_frame;
   // At this point, we're already beyond the popup blocker. Even if the popup
   // was created without a user gesture, we have to set |user_gesture| to true,
   // so it gets correctly focused.
