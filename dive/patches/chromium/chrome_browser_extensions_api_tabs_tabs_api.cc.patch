diff --git a/chrome/browser/extensions/api/tabs/tabs_api.cc b/chrome/browser/extensions/api/tabs/tabs_api.cc
index df2d3177c4..3870c98731 100644
--- a/chrome/browser/extensions/api/tabs/tabs_api.cc
+++ b/chrome/browser/extensions/api/tabs/tabs_api.cc
@@ -2,7 +2,12 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.

+#pragma clang diagnostic ignored "-Wunused-but-set-variable"
+
 #include "chrome/browser/extensions/api/tabs/tabs_api.h"
+#include "ui/display/screen.h"
+
+#include "ui/gfx/image/image_skia_operations.h"

 #include <stddef.h>
 #include <algorithm>
@@ -12,6 +17,14 @@
 #include <utility>
 #include <vector>

+#include "content/nw/src/nw_base.h"
+#include "content/nw/src/browser/nw_content_browser_hooks.h"
+#if defined(OS_MAC)
+#include "content/nw/src/nw_content_mac.h"
+#endif
+#include "chrome/browser/ui/views/frame/browser_view.h"
+#include "extensions/browser/extension_registry.h"
+
 #include "base/bind.h"
 #include "base/check_op.h"
 #include "base/command_line.h"
@@ -128,6 +141,8 @@
 #include "ui/views/widget/desktop_aura/desktop_window_tree_host_lacros.h"
 #endif

+#include "extensions/browser/guest_view/web_view/web_view_guest.h"
+
 using content::BrowserThread;
 using content::NavigationController;
 using content::NavigationEntry;
@@ -254,6 +269,8 @@ void AssignOptionalValue(const std::unique_ptr<T>& source,

 ui::WindowShowState ConvertToWindowShowState(windows::WindowState state) {
   switch (state) {
+    case windows::WINDOW_STATE_HIDDEN:
+      return ui::SHOW_STATE_HIDDEN;
     case windows::WINDOW_STATE_NORMAL:
       return ui::SHOW_STATE_NORMAL;
     case windows::WINDOW_STATE_MINIMIZED:
@@ -286,9 +303,10 @@ bool IsValidStateForWindowsCreateFunction(
     case windows::WINDOW_STATE_FULLSCREEN:
     case windows::WINDOW_STATE_LOCKED_FULLSCREEN:
       // If maximised/fullscreen, default focused state should be focused.
-      return !(create_data->focused && !*create_data->focused) && !has_bound;
+      return true; //!(create_data->focused && !*create_data->focused) && !has_bound;
     case windows::WINDOW_STATE_NORMAL:
     case windows::WINDOW_STATE_NONE:
+    case windows::WINDOW_STATE_HIDDEN:
       return true;
   }
   NOTREACHED();
@@ -654,12 +672,28 @@ ExtensionFunction::ResponseAction WindowsCreateFunction::Run() {
   if (!IsValidStateForWindowsCreateFunction(create_data))
     return RespondNow(Error(tabs_constants::kInvalidWindowStateError));

-  Browser::Type window_type = Browser::TYPE_NORMAL;
+  Browser::Type window_type = Browser::TYPE_POPUP;

   gfx::Rect window_bounds;
   bool focused = true;
+  bool hidden = false;
+  bool new_instance = false;
+  bool mixed_context = false;
+  bool frameless = false;
+  bool kiosk = false;
+  bool transparent = false;
+  bool always_on_top = false;
+  bool all_visible = false;
+  bool show_in_taskbar = true;
+  bool resizable = true;
+  bool block_parser = false;
+  std::string title;
+  int min_width = 0; int min_height = 0; int max_width = 0; int max_height = 0;
   std::string extension_id;
+  std::string position;
+  std::string windows_key;

+  std::string inject_js_start, inject_js_end;
   if (create_data) {
     // Figure out window type before figuring out bounds so that default
     // bounds can be set according to the window type.
@@ -680,8 +714,9 @@ ExtensionFunction::ResponseAction WindowsCreateFunction::Run() {

     // Initialize default window bounds according to window type.
     ui::WindowShowState ignored_show_state = ui::SHOW_STATE_DEFAULT;
+    gfx::Rect ignored_window_bounds;
     WindowSizer::GetBrowserWindowBoundsAndShowState(
-        gfx::Rect(), nullptr, &window_bounds, &ignored_show_state);
+        gfx::Rect(), nullptr, &ignored_window_bounds, &ignored_show_state);

     // Update the window bounds based on the create parameters.
     bool set_window_position = false;
@@ -717,8 +752,60 @@ ExtensionFunction::ResponseAction WindowsCreateFunction::Run() {
       return RespondNow(Error(tabs_constants::kInvalidWindowBoundsError));
     }

+    if (create_data->min_width) {
+      min_width = *create_data->min_width;
+      if (window_bounds.width())
+        window_bounds.set_width(std::max(min_width, window_bounds.width()));
+    }
+    if (create_data->max_width) {
+      max_width = *create_data->max_width;
+      window_bounds.set_width(std::min(max_width, window_bounds.width()));
+    }
+    if (create_data->min_height) {
+      min_height = *create_data->min_height;
+      if (window_bounds.height())
+        window_bounds.set_height(std::max(min_height, window_bounds.height()));
+    }
+    if (create_data->max_height) {
+      max_height = *create_data->max_height;
+      window_bounds.set_height(std::min(max_height, window_bounds.height()));
+    }
+
     if (create_data->focused)
       focused = *create_data->focused;
+
+    if (create_data->hidden)
+      hidden = *create_data->hidden;
+    if (create_data->inject_js_start)
+      inject_js_start = *create_data->inject_js_start;
+    if (create_data->inject_js_end)
+      inject_js_end = *create_data->inject_js_end;
+    if (create_data->new_instance)
+      new_instance = *create_data->new_instance;
+    if (create_data->mixed_context)
+      mixed_context = *create_data->mixed_context;
+    if (create_data->frameless)
+      frameless = *create_data->frameless;
+    if (create_data->kiosk)
+      kiosk = *create_data->kiosk;
+    if (create_data->alpha_enabled)
+      transparent = *create_data->alpha_enabled;
+    if (create_data->always_on_top)
+      always_on_top = *create_data->always_on_top;
+    if (create_data->all_visible)
+      all_visible = *create_data->all_visible;
+    if (create_data->resizable)
+      resizable = *create_data->resizable;
+    if (create_data->show_in_taskbar)
+      show_in_taskbar = *create_data->show_in_taskbar;
+    if (create_data->title)
+      title = *create_data->title;
+    if (create_data->position)
+      position = *create_data->position;
+    if (create_data->block_parser)
+      block_parser = *create_data->block_parser;
+    if (create_data->id)
+      windows_key = *create_data->id;
   }

   // Create a new BrowserWindow if possible.
@@ -728,16 +815,46 @@ ExtensionFunction::ResponseAction WindowsCreateFunction::Run() {
   }
   Browser::CreateParams create_params(window_type, window_profile,
                                       user_gesture());
+
   if (extension_id.empty()) {
     create_params.initial_bounds = window_bounds;
   } else {
     // extension_id is only set for CREATE_TYPE_POPUP.
     create_params = Browser::CreateParams::CreateForAppPopup(
         web_app::GenerateApplicationNameFromAppId(extension_id),
-        false /* trusted_source */, window_bounds, window_profile,
+        extension() && extension()->is_nwjs_app() /* trusted_source */, window_bounds, window_profile,
         user_gesture());
   }
-  create_params.initial_show_state = ui::SHOW_STATE_NORMAL;
+  create_params.extension_id = extension_id;
+  create_params.windows_key = windows_key;
+  create_params.frameless = frameless;
+  create_params.alpha_enabled = transparent;
+  create_params.always_on_top = always_on_top;
+  create_params.all_visible = all_visible;
+  create_params.resizable = resizable;
+  create_params.show_in_taskbar = show_in_taskbar;
+  create_params.title = title;
+
+  if (create_data && create_data->icon) {
+    base::ThreadRestrictions::ScopedAllowIO allow_io;
+    gfx::Image app_icon;
+    nw::Package* package = nw::package();
+    if (nw::GetPackageImage(package,
+                            base::FilePath::FromUTF8Unsafe(*create_data->icon),
+                            &app_icon)) {
+      if (app_icon.Width() > 128 || app_icon.Height() > 128) {
+        const gfx::ImageSkia* originImageSkia = app_icon.ToImageSkia();
+        gfx::ImageSkia resizedImageSkia =
+          gfx::ImageSkiaOperations::CreateResizedImage(*originImageSkia,
+                                                       skia::ImageOperations::RESIZE_GOOD,
+                                                       gfx::Size(128, 128));
+        app_icon = gfx::Image(resizedImageSkia);
+      }
+      create_params.icon = app_icon;
+    }
+  }
+
+  create_params.initial_show_state = ui::SHOW_STATE_DEFAULT;
   if (create_data && create_data->state) {
     if (create_data->state == windows::WINDOW_STATE_LOCKED_FULLSCREEN &&
         !ExtensionHasLockedFullscreenPermission(extension())) {
@@ -748,10 +865,19 @@ ExtensionFunction::ResponseAction WindowsCreateFunction::Run() {
         ConvertToWindowShowState(create_data->state);
   }

+  create_params.position = position;
   Browser* new_window = Browser::Create(create_params);
   if (!new_window)
     return RespondNow(Error(tabs_constants::kBrowserWindowNotAllowed));

+  BrowserFrame* frame = BrowserView::GetBrowserViewForBrowser(new_window)->frame();
+
+  if (kiosk) {
+    frame->SetFullscreen(true);
+#if defined(OS_MAC)
+    NWSetNSAppKioskOptions();
+#endif
+  }
   for (const GURL& url : urls) {
     NavigateParams navigate_params(new_window, url, ui::PAGE_TRANSITION_LINK);
     navigate_params.disposition = WindowOpenDisposition::NEW_FOREGROUND_TAB;
@@ -778,7 +904,19 @@ ExtensionFunction::ResponseAction WindowsCreateFunction::Run() {
           render_frame_host()->GetSiteInstance();
     }

+    navigate_params.inject_js_start = inject_js_start;
+    navigate_params.inject_js_end = inject_js_end;
+    navigate_params.block_parser = block_parser;
+
+    if (new_instance)
+      nw::SetPinningRenderer(false);
+    if (mixed_context)
+      nw::SetMixedContext(true);
     Navigate(&navigate_params);
+    if (mixed_context)
+      nw::SetMixedContext(false);
+    if (new_instance)
+      nw::SetPinningRenderer(true);
   }

   WebContents* contents = NULL;
@@ -807,6 +945,19 @@ ExtensionFunction::ResponseAction WindowsCreateFunction::Run() {
       TabStripUserGestureDetails(
           TabStripUserGestureDetails::GestureType::kNone));

+  new_window->window()->SetMinimumSize(gfx::Size(min_width, min_height));
+  new_window->window()->SetMaximumSize(gfx::Size(max_width, max_height));
+#if defined(OS_LINUX) || defined(OS_WIN)
+  if (!resizable)
+    new_window->window()->SetResizable(false);
+#endif
+
+  if (create_params.initial_show_state == ui::SHOW_STATE_FULLSCREEN) {
+    BrowserFrame* frame = BrowserView::GetBrowserViewForBrowser(new_window)->frame();
+    frame->SetFullscreen(true);
+  }
+
+  if (!hidden) {
   if (focused) {
     new_window->window()->Show();
   } else {
@@ -831,6 +982,9 @@ ExtensionFunction::ResponseAction WindowsCreateFunction::Run() {
     if (reset_active && base::Contains(*browser_list, active_browser))
       active_browser->window()->Activate();
   }
+  } else {
+    new_window->window()->Hide();
+  }

   // Lock the window fullscreen only after the new tab has been created
   // (otherwise the tabstrip is empty), and window()->show() has been called
@@ -852,9 +1006,26 @@ ExtensionFunction::ResponseAction WindowsCreateFunction::Run() {
         *new_window, extension(), ExtensionTabUtil::kPopulateTabs,
         source_context_type());
   }
+  if (new_window->DidFinishFirstNavigation())
+    return RespondNow(OneArgument(base::Value::FromUniquePtrValue(std::move(result))));
+  new_window->AddOnDidFinishFirstNavigationCallback(
+    base::BindOnce(&WindowsCreateFunction::
+                   OnFinishedFirstNavigationOrClosed,
+                   this, OneArgument(base::Value::FromUniquePtrValue(std::move(result)))));
+  return RespondLater();
+}

-  return RespondNow(
-      OneArgument(base::Value::FromUniquePtrValue(std::move(result))));
+void WindowsCreateFunction::OnFinishedFirstNavigationOrClosed(
+    ResponseValue result_arg,
+    bool did_finish) {
+  DCHECK(!did_respond());
+
+  if (!did_finish) {
+    Respond(Error("Browser is closed before ready to commit first navigation."));
+    return;
+  }
+
+  Respond(std::move(result_arg));
 }

 ExtensionFunction::ResponseAction WindowsUpdateFunction::Run() {
@@ -891,21 +1062,71 @@ ExtensionFunction::ResponseAction WindowsUpdateFunction::Run() {
                                 ? browser->window()->GetRestoredBounds()
                                 : browser->window()->GetBounds();
   bool set_window_bounds = false;
+  bool set_pos_only = false;
+
+  bool set_min_size = false;
+  bool set_max_size = false;
+  gfx::Size min_size = BrowserView::GetBrowserViewForBrowser(browser)->GetMinimumSize();
+  gfx::Size max_size = BrowserView::GetBrowserViewForBrowser(browser)->GetMaximumSize();
+  if (params->update_info.min_width) {
+    min_size.set_width(*params->update_info.min_width);
+    set_min_size = true;
+  }
+  if (params->update_info.min_height) {
+    min_size.set_height(*params->update_info.min_height);
+    set_min_size = true;
+  }
+  if (params->update_info.max_width) {
+    max_size.set_width(*params->update_info.max_width);
+    set_max_size = true;
+  }
+  if (params->update_info.max_height) {
+    max_size.set_height(*params->update_info.max_height);
+    set_max_size = true;
+  }
+  if (set_min_size)
+    browser->window()->SetMinimumSize(min_size);
+  if (set_max_size)
+    browser->window()->SetMaximumSize(max_size);
   if (params->update_info.left) {
     window_bounds.set_x(*params->update_info.left);
     set_window_bounds = true;
+    set_pos_only = true;
   }
   if (params->update_info.top) {
     window_bounds.set_y(*params->update_info.top);
     set_window_bounds = true;
+    set_pos_only = true;
   }
   if (params->update_info.width) {
     window_bounds.set_width(*params->update_info.width);
     set_window_bounds = true;
+    set_pos_only = false;
   }
   if (params->update_info.height) {
     window_bounds.set_height(*params->update_info.height);
     set_window_bounds = true;
+    set_pos_only = false;
+  }
+
+  bool set_client_bounds = false;
+  BrowserFrame* frame = BrowserView::GetBrowserViewForBrowser(browser)->frame();
+  gfx::Rect client_bounds = frame->non_client_view()->frame_view()->GetBoundsForClientView();
+  client_bounds.Offset(window_bounds.OffsetFromOrigin());
+
+  if (params->update_info.inner_width) {
+    client_bounds.set_width(*params->update_info.inner_width);
+    set_client_bounds = true;
+  }
+
+  if (params->update_info.inner_height) {
+    client_bounds.set_height(*params->update_info.inner_height);
+    set_client_bounds = true;
+  }
+
+  if (set_client_bounds) {
+    gfx::Rect win_bounds = frame->non_client_view()->GetWindowBoundsForClientBounds(client_bounds);
+    browser->window()->SetBounds(win_bounds);
   }

   if (set_window_bounds && !WindowBoundsIntersectDisplays(window_bounds))
@@ -967,8 +1188,12 @@ ExtensionFunction::ResponseAction WindowsUpdateFunction::Run() {
           true, extension()->url());
       break;
     case ui::SHOW_STATE_NORMAL:
+      browser->window()->Show();
       browser->window()->Restore();
       break;
+    case ui::SHOW_STATE_HIDDEN:
+      browser->window()->Hide();
+      break;
     default:
       break;
   }
@@ -976,7 +1201,25 @@ ExtensionFunction::ResponseAction WindowsUpdateFunction::Run() {
   if (set_window_bounds) {
     // TODO(varkha): Updating bounds during a drag can cause problems and a more
     // general solution is needed. See http://crbug.com/251813 .
-    browser->window()->SetBounds(window_bounds);
+#if defined(OS_WIN)
+    if (set_pos_only)
+      browser->window()->SetPosition(window_bounds.origin());
+    else
+#endif
+      browser->window()->SetBounds(window_bounds);
+  }
+
+  if (params->update_info.position &&
+      *params->update_info.position == "center")
+    BrowserView::GetBrowserViewForBrowser(browser)->frame()->CenterWindow(window_bounds.size());
+  if (params->update_info.position &&
+      *params->update_info.position == "mouse") {
+    BrowserFrame* browser_frame =
+      BrowserView::GetBrowserViewForBrowser(browser)->frame();
+      gfx::Point cursor_pos(display::Screen::GetScreen()->GetCursorScreenPoint());
+      gfx::Rect bounds = browser_frame->GetWindowBoundsInScreen();
+      bounds.set_origin(cursor_pos);
+      browser_frame->SetBounds(bounds);
   }

   if (params->update_info.focused) {
@@ -987,6 +1230,16 @@ ExtensionFunction::ResponseAction WindowsUpdateFunction::Run() {
     }
   }

+  if (params->update_info.show && *params->update_info.show)
+    browser->window()->Show();
+  if (params->update_info.resizable)
+    browser->window()->SetResizable(*params->update_info.resizable);
+  if (params->update_info.all_visible)
+    browser->window()->SetAllVisible(*params->update_info.all_visible);
+  if (params->update_info.always_on_top)
+    browser->window()->SetZOrderLevel(*params->update_info.always_on_top ? ui::ZOrderLevel::kFloatingWindow : ui::ZOrderLevel::kNormal);
+  if (params->update_info.show_in_taskbar)
+    browser->window()->SetShowInTaskbar(*params->update_info.show_in_taskbar);
   if (params->update_info.draw_attention)
     browser->window()->FlashFrame(*params->update_info.draw_attention);

@@ -1288,6 +1541,7 @@ ExtensionFunction::ResponseAction TabsCreateFunction::Run() {
   AssignOptionalValue(params->create_properties.index, &options.index);
   AssignOptionalValue(params->create_properties.url, &options.url);

+  options.create_browser_if_needed = true;
   std::string error;
   std::unique_ptr<base::DictionaryValue> result(
       ExtensionTabUtil::OpenTab(this, options, user_gesture(), &error));
@@ -2254,6 +2508,8 @@ ExtensionFunction::ResponseAction TabsDetectLanguageFunction::Run() {
       tabs::DetectLanguage::Params::Create(args()));
   EXTENSION_FUNCTION_VALIDATE(params.get());

+  return RespondNow(Error("disabled in NW.js"));
+#if 0
   int tab_id = 0;
   Browser* browser = NULL;
   WebContents* contents = NULL;
@@ -2316,6 +2572,7 @@ ExtensionFunction::ResponseAction TabsDetectLanguageFunction::Run() {
   is_observing_ = true;

   return RespondLater();
+#endif
 }

 void TabsDetectLanguageFunction::NavigationEntryCommitted(
@@ -2340,9 +2597,11 @@ void TabsDetectLanguageFunction::RespondWithLanguage(
     const std::string& language) {
   // Stop observing.
   if (is_observing_) {
+#if 0
     ChromeTranslateClient::FromWebContents(web_contents())
         ->GetTranslateDriver()
         ->RemoveLanguageDetectionObserver(this);
+#endif
     Observe(nullptr);
   }

@@ -2477,12 +2736,17 @@ ScriptExecutor* ExecuteCodeInTabFunction::GetScriptExecutor(
   bool success = GetTabById(execute_tab_id_, browser_context(),
                             include_incognito_information(), &browser, nullptr,
                             &contents, nullptr, error) &&
-                 contents && browser;
+                 contents;

   if (!success)
     return nullptr;

-  return TabHelper::FromWebContents(contents)->script_executor();
+  if (TabHelper::FromWebContents(contents))
+    return TabHelper::FromWebContents(contents)->script_executor();
+  auto* web_view = extensions::WebViewGuest::FromWebContents(contents);
+  if (web_view)
+    return web_view->script_executor();
+  return nullptr;
 }

 bool ExecuteCodeInTabFunction::IsWebView() const {
