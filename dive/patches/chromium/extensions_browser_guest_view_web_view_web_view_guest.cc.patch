diff --git a/extensions/browser/guest_view/web_view/web_view_guest.cc b/extensions/browser/guest_view/web_view/web_view_guest.cc
index eda3ff02d9..8c6fddd79c 100644
--- a/extensions/browser/guest_view/web_view/web_view_guest.cc
+++ b/extensions/browser/guest_view/web_view/web_view_guest.cc
@@ -4,7 +4,14 @@

 #include "extensions/browser/guest_view/web_view/web_view_guest.h"

+#include "content/nw/src/nw_content.h"
+#include "content/public/common/content_client.h"
+#include "content/public/browser/content_browser_client.h"
+
 #include <stddef.h>
+#include "content/nw/src/nw_content.h"
+#include "extensions/browser/extension_registry.h"
+#include "extensions/common/manifest_handlers/webview_info.h"

 #include <map>
 #include <memory>
@@ -312,6 +319,7 @@ void WebViewGuest::CreateWebContents(const base::Value::Dict& create_params,
   std::string storage_partition_id;
   bool persist_storage = false;
   ParsePartitionParam(create_params, &storage_partition_id, &persist_storage);
+
   // Validate that the partition id coming from the renderer is valid UTF-8,
   // since we depend on this in other parts of the code, such as FilePath
   // creation. If the validation fails, treat it as a bad message and kill the
@@ -761,6 +769,7 @@ WebViewGuest::WebViewGuest(WebContents* owner_web_contents)
     : GuestView<WebViewGuest>(owner_web_contents),
       rules_registry_id_(RulesRegistryService::kInvalidRulesRegistryID),
       find_helper_(this),
+      allow_nw_(false),
       javascript_dialog_helper_(this),
       web_view_guest_delegate_(base::WrapUnique(
           ExtensionsAPIClient::Get()->CreateWebViewGuestDelegate(this))),
@@ -1162,6 +1171,11 @@ void WebViewGuest::ApplyAttributes(const base::Value::Dict& params) {
   if (allow_scaling)
     SetAllowScaling(*allow_scaling);

+  absl::optional<bool> allow_nw = params.FindBool(webview::kAttributeAllowNW);
+  if (allow_nw) {
+    allow_nw_ = *allow_nw;
+  }
+
   // Check for a pending zoom from before the first navigation.
   pending_zoom_factor_ = params.FindDouble(webview::kInitialZoomFactor)
                              .value_or(pending_zoom_factor_);
@@ -1285,11 +1299,14 @@ bool WebViewGuest::LoadDataWithBaseURL(const GURL& data_url,
   }
   const url::Origin& owner_origin =
       owner_web_contents()->GetPrimaryMainFrame()->GetLastCommittedOrigin();
+  bool owner_is_nwjs =
+    content::GetContentClient()->browser()->IsNWOrigin(owner_origin, browser_context());
   const bool base_in_owner_origin = owner_origin.IsSameOriginWith(base_url);
   // |base_url| must be a valid URL. It is also limited to URLs that the owner
   // is trusted to have control over.
   if (!base_url.is_valid() ||
-      (!base_url.SchemeIsHTTPOrHTTPS() && !base_in_owner_origin)) {
+      (!base_url.SchemeIsHTTPOrHTTPS() && !base_in_owner_origin &&
+       !owner_is_nwjs)) {
     base::SStringPrintf(error, webview::kAPILoadDataInvalidBaseURL,
                         base_url.possibly_invalid_spec().c_str());
     return false;
@@ -1399,7 +1416,8 @@ void WebViewGuest::WebContentsCreated(WebContents* source_contents,
                                       int opener_render_frame_id,
                                       const std::string& frame_name,
                                       const GURL& target_url,
-                                      WebContents* new_contents) {
+                                      WebContents* new_contents,
+                                      const std::u16string& nw_window_manifest) {
   auto* guest = WebViewGuest::FromWebContents(new_contents);
   CHECK(guest);
   guest->SetOpener(this);
@@ -1450,6 +1468,17 @@ void WebViewGuest::RequestToLockMouse(WebContents* web_contents,
           base::Unretained(web_contents)));
 }

+bool WebViewGuest::CanLoadFileSubresource(const GURL& url) {
+  GURL test_file_url("file:///");
+  const Extension* extension =
+      ExtensionRegistry::Get(browser_context())->enabled_extensions().GetByID(owner_host());
+  if (extension && WebviewInfo::IsURLWebviewAccessible(extension,
+                                                       GetPartitionID(web_contents()->GetRenderViewHost()->GetProcess()),
+                                                       test_file_url))
+    return true;
+  return false;
+}
+
 void WebViewGuest::LoadURLWithParams(
     const GURL& url,
     const content::Referrer& referrer,
@@ -1467,6 +1496,16 @@ void WebViewGuest::LoadURLWithParams(
        !url.SchemeIs(url::kAboutScheme)) ||
       url.SchemeIs(url::kJavaScriptScheme);

+  if (scheme_is_blocked) {
+    const Extension* extension =
+      ExtensionRegistry::Get(browser_context())->enabled_extensions().GetByID(owner_host());
+    if (extension && WebviewInfo::IsURLWebviewAccessible(extension,
+                                                         GetPartitionID(web_contents()->GetRenderViewHost()->GetProcess()),
+                                                         url)) {
+      scheme_is_blocked = false;
+    }
+  }
+
   // Do not allow navigating a guest to schemes other than known safe schemes.
   // This will block the embedder trying to load unwanted schemes, e.g.
   // chrome://.
@@ -1499,7 +1538,10 @@ void WebViewGuest::LoadURLWithParams(
     load_url_params.override_user_agent =
         content::NavigationController::UA_OVERRIDE_TRUE;
   }
+  nw::SetInWebViewApplyAttr(true, allow_nw_);
   web_contents()->GetController().LoadURLWithParams(load_url_params);
+  nw::SetInWebViewApplyAttr(false, allow_nw_);
+
 }

 void WebViewGuest::RequestNewWindowPermission(WindowOpenDisposition disposition,
@@ -1572,6 +1614,21 @@ void WebViewGuest::OnFullscreenPermissionDecided(
   SetFullscreenState(allowed);
 }

+void WebViewGuest::ShowDevTools(bool show, int proc_id, int guest_id) {
+  if (proc_id > 0 && guest_id >= 0) {
+    auto* that =
+      WebViewGuest::From(owner_web_contents()->GetRenderViewHost()->GetProcess()->GetID(),
+                         guest_id);
+    nw::ShowDevtools(show, web_contents(), that->web_contents());
+    return;
+  }
+  nw::ShowDevtools(show, web_contents());
+}
+
+void WebViewGuest::InspectElement(int x, int y) {
+  nw::InspectElement(web_contents(), x, y);
+}
+
 bool WebViewGuest::GuestMadeEmbedderFullscreen() const {
   return last_fullscreen_permission_was_allowed_by_embedder_ &&
          is_embedder_fullscreen_;
