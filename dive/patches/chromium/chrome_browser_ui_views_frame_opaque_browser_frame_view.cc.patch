diff --git a/chrome/browser/ui/views/frame/opaque_browser_frame_view.cc b/chrome/browser/ui/views/frame/opaque_browser_frame_view.cc
index 687f5bd6fc..b41e7b370b 100644
--- a/chrome/browser/ui/views/frame/opaque_browser_frame_view.cc
+++ b/chrome/browser/ui/views/frame/opaque_browser_frame_view.cc
@@ -128,6 +128,7 @@ OpaqueBrowserFrameView::OpaqueBrowserFrameView(
     BrowserView* browser_view,
     OpaqueBrowserFrameViewLayout* layout)
     : BrowserNonClientFrameView(frame, browser_view),
+      frameless_(frame->frameless()),
       layout_(layout),
       window_icon_(nullptr),
       window_title_(nullptr),
@@ -143,6 +144,8 @@ OpaqueBrowserFrameView::OpaqueBrowserFrameView(
     layout_->SetBorderlessModeEnabled(browser_view->IsBorderlessModeEnabled(),
                                       this);
   }
+  if (frameless_)
+    return;
   SetLayoutManager(std::unique_ptr<views::LayoutManager>(layout_));
 }

@@ -200,7 +203,7 @@ void OpaqueBrowserFrameView::InitViews() {
       close_button_,
       base::BindRepeating(&BrowserFrame::CloseWithReason,
                           base::Unretained(frame()),
-                          views::Widget::ClosedReason::kCloseButtonClicked),
+                          views::Widget::ClosedReason::kCloseButtonClicked, false),
       IDS_ACCNAME_CLOSE, VIEW_ID_CLOSE_BUTTON);

   // Initializing the TabIconView is expensive, so only do it if we need to.
@@ -297,19 +300,45 @@ void OpaqueBrowserFrameView::OnThemeChanged() {
   UpdateCaptionButtonPlaceholderContainerBackground();
   BrowserNonClientFrameView::OnThemeChanged();
 }
+
+gfx::Size OpaqueBrowserFrameView::GetMaximumSize() const {
+  return layout_->GetMaximumSize(this);
+}
+
 ///////////////////////////////////////////////////////////////////////////////
 // OpaqueBrowserFrameView, views::NonClientFrameView implementation:

 gfx::Rect OpaqueBrowserFrameView::GetBoundsForClientView() const {
+  if (frameless_)
+    return bounds();
   return layout_->client_view_bounds();
 }

 gfx::Rect OpaqueBrowserFrameView::GetWindowBoundsForClientBounds(
     const gfx::Rect& client_bounds) const {
+  if (frameless_) {
+    gfx::Rect window_bounds = client_bounds;
+    if (window_bounds.IsEmpty()) {
+      window_bounds.set_width(1);
+      window_bounds.set_height(1);
+    }
+    return window_bounds;
+  }
   return layout_->GetWindowBoundsForClientBounds(client_bounds);
 }

 int OpaqueBrowserFrameView::NonClientHitTest(const gfx::Point& point) {
+  if (frameless_) {
+    constexpr int kResizeAreaCornerSize = 16;
+    views::WidgetDelegate* delegate = frame()->widget_delegate();
+    if (!delegate)
+      return HTCAPTION;
+    int window_component = GetHTComponentForFrame(
+      point, gfx::Insets(5),
+      kResizeAreaCornerSize, kResizeAreaCornerSize, delegate->CanResize());
+    if (window_component != HTNOWHERE)
+      return window_component;
+  }
   int super_component = BrowserNonClientFrameView::NonClientHitTest(point);
   if (super_component != HTNOWHERE)
     return super_component;
@@ -317,6 +346,10 @@ int OpaqueBrowserFrameView::NonClientHitTest(const gfx::Point& point) {
   if (!bounds().Contains(point))
     return HTNOWHERE;

+  SkRegion* draggable_region = browser_view()->GetDraggableRegion();
+  if (draggable_region && draggable_region->contains(point.x(), point.y()))
+    return HTCAPTION;
+
   int frame_component = frame()->client_view()->NonClientHitTest(point);

   // See if we're in the sysmenu region.  We still have to check the tabstrip
@@ -398,10 +431,17 @@ void OpaqueBrowserFrameView::GetWindowMask(const gfx::Size& size,
 }

 void OpaqueBrowserFrameView::ResetWindowControls() {
+  if (frameless_)
+    return;
   BrowserNonClientFrameView::ResetWindowControls();
-  restore_button_->SetState(views::Button::STATE_NORMAL);
   minimize_button_->SetState(views::Button::STATE_NORMAL);
-  maximize_button_->SetState(views::Button::STATE_NORMAL);
+  if (browser_view()->CanMaximize()) {
+    restore_button_->SetState(views::Button::STATE_NORMAL);
+    maximize_button_->SetState(views::Button::STATE_NORMAL);
+  } else {
+    restore_button_->SetState(views::Button::STATE_DISABLED);
+    maximize_button_->SetState(views::Button::STATE_DISABLED);
+  }
   // The close button isn't affected by this constraint.
 }

@@ -411,6 +451,8 @@ void OpaqueBrowserFrameView::UpdateWindowIcon() {
 }

 void OpaqueBrowserFrameView::UpdateWindowTitle() {
+  if (frameless_)
+    return;
   if (!frame()->IsFullscreen() && ShouldShowWindowTitle()) {
     Layout();
     window_title_->SchedulePaint();
@@ -485,6 +527,10 @@ gfx::Size OpaqueBrowserFrameView::GetBrowserViewMinimumSize() const {
   return browser_view()->GetMinimumSize();
 }

+gfx::Size OpaqueBrowserFrameView::GetBrowserViewMaximumSize() const {
+  return browser_view()->GetMaximumSize();
+}
+
 bool OpaqueBrowserFrameView::ShouldShowCaptionButtons() const {
   return GetShowWindowTitleBar();
 }
@@ -586,7 +632,7 @@ bool OpaqueBrowserFrameView::ShouldDrawRestoredFrameShadow() const {
 // views::View:
 void OpaqueBrowserFrameView::OnPaint(gfx::Canvas* canvas) {
   TRACE_EVENT0("views.frame", "OpaqueBrowserFrameView::OnPaint");
-  if (frame()->IsFullscreen())
+  if (frame()->IsFullscreen() || frameless_)
     return;  // Nothing is visible, so don't bother to paint.

   const bool active = ShouldPaintAsActive();
@@ -787,6 +833,8 @@ bool OpaqueBrowserFrameView::GetShowWindowTitleBar() const {
   if (frame()->IsFullscreen())
     return false;

+  if (frameless_)
+    return false;
   // Do not show caption buttons if the window manager is forcefully providing a
   // title bar (e.g., in Ubuntu Unity, if the window is maximized).
   return !views::ViewsDelegate::GetInstance()->WindowManagerProvidesTitleBar(
