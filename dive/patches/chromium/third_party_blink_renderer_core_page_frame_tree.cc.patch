diff --git a/third_party/blink/renderer/core/page/frame_tree.cc b/third_party/blink/renderer/core/page/frame_tree.cc
index 8417e3ef38..36b15708b2 100644
--- a/third_party/blink/renderer/core/page/frame_tree.cc
+++ b/third_party/blink/renderer/core/page/frame_tree.cc
@@ -187,12 +187,12 @@ unsigned FrameTree::ChildCount() const {
   return count;
 }

-Frame* FrameTree::FindFrameByName(const AtomicString& name) const {
+Frame* FrameTree::FindFrameByName(const AtomicString& name, bool nw) const {
   // Named frame lookup should always be relative to a local frame.
   DCHECK(IsA<LocalFrame>(this_frame_.Get()));

   Frame* frame = FindFrameForNavigationInternal(name, KURL());
-  if (frame && !To<LocalFrame>(this_frame_.Get())->CanNavigate(*frame))
+  if (!nw && frame && !To<LocalFrame>(this_frame_.Get())->CanNavigate(*frame))
     frame = nullptr;
   return frame;
 }
@@ -203,18 +203,36 @@ FrameTree::FindResult FrameTree::FindOrCreateFrameForNavigation(
   // Named frame lookup should always be relative to a local frame.
   DCHECK(IsA<LocalFrame>(this_frame_.Get()));
   LocalFrame* current_frame = To<LocalFrame>(this_frame_.Get());
+  bool policy_changed = false;

+  NavigationPolicy policy = request.GetNavigationPolicy();
+  NavigationPolicy policy0 = policy;
+  if (name == "_blank")
+    policy = kNavigationPolicyNewWindow;
+
+  const KURL& url = request.GetResourceRequest().Url();
+  Frame* frame = FindFrameForNavigationInternal(name, url, &request);
+
+  if (!frame || policy != kNavigationPolicyCurrentTab) {
+    WebString manifest;
+    current_frame->Client()->willHandleNavigationPolicy(request.GetResourceRequest(), &policy, &manifest);
+    if (policy == kNavigationPolicyIgnore)
+      return FindResult(nullptr, false);
+    request.SetNavigationPolicy(policy);
+    request.SetManifest(manifest);
+    if (!manifest.IsEmpty() || policy != policy0)
+      policy_changed = true;
+  }
   // A GetNavigationPolicy() value other than kNavigationPolicyCurrentTab at
   // this point indicates that a user event modified the navigation policy
   // (e.g., a ctrl-click). Let the user's action override any target attribute.
-  if (request.GetNavigationPolicy() != kNavigationPolicyCurrentTab)
+  if (policy0 != kNavigationPolicyCurrentTab && !policy_changed)
     return FindResult(current_frame, false);

-  const KURL& url = request.GetResourceRequest().Url();
-  Frame* frame = FindFrameForNavigationInternal(name, url, &request);
   bool new_window = false;
   if (!frame) {
-    frame = CreateNewWindow(*current_frame, request, name);
+    WebString manifest = request.GetManifest();
+    frame = CreateNewWindow(*current_frame, request, name, &manifest);
     new_window = true;
     // CreateNewWindow() might have modified NavigationPolicy.
     // Set it back now that the new window is known to be the right one.
@@ -249,8 +267,13 @@ Frame* FrameTree::FindFrameForNavigationInternal(
     return this_frame_;
   }

-  if (EqualIgnoringASCIICase(name, "_top"))
+  if (EqualIgnoringASCIICase(name, "_top")) {
+    for (const LocalFrame* f = DynamicTo<LocalFrame>(this_frame_.Get()); f; f = DynamicTo<LocalFrame>(f->Tree().Parent())) {
+      if (f->isNwFakeTop())
+        return const_cast<LocalFrame*>(f);
+    }
     return &Top(FrameTreeBoundary::kFenced);
+  }

   // The target _unfencedTop should only be treated as a special name in
   // opaque-ads mode fenced frames.
@@ -268,6 +291,8 @@ Frame* FrameTree::FindFrameForNavigationInternal(
   }

   if (EqualIgnoringASCIICase(name, "_parent")) {
+    if (this_frame_->isNwFakeTop())
+      return this_frame_.Get();
     return Parent(FrameTreeBoundary::kFenced)
                ? Parent(FrameTreeBoundary::kFenced)
                : this_frame_.Get();
