diff --git a/chrome/browser/chrome_content_browser_client.cc b/chrome/browser/chrome_content_browser_client.cc
index 0b6592cfa2..51e7e24708 100644
--- a/chrome/browser/chrome_content_browser_client.cc
+++ b/chrome/browser/chrome_content_browser_client.cc
@@ -1,8 +1,11 @@
 // Copyright (c) 2012 The Chromium Authors. All rights reserved.
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
+#pragma clang diagnostic ignored "-Wunreachable-code"

 #include "chrome/browser/chrome_content_browser_client.h"
+#include "content/browser/renderer_host/render_process_host_impl.h"
+#include "components/crash/core/app/crash_reporter_client.h"

 #include <iterator>
 #include <map>
@@ -11,6 +14,12 @@
 #include <utility>
 #include <vector>

+#include "content/nw/src/common/nw_content_common_hooks.h"
+#include "content/nw/src/common/shell_switches.h"
+#include "content/nw/src/nw_content.h"
+#include "content/nw/src/nw_base.h"
+#include "chrome/browser/profiles/profile_manager.h"
+
 #include "base/base_switches.h"
 #include "base/bind.h"
 #include "base/callback.h"
@@ -554,6 +563,7 @@
 #include "extensions/browser/extension_navigation_throttle.h"
 #include "extensions/browser/extension_protocols.h"
 #include "extensions/browser/extension_registry.h"
+#include "chrome/browser/extensions/extension_service.h"
 #include "extensions/browser/extension_util.h"
 #include "extensions/browser/guest_view/web_view/web_view_guest.h"
 #include "extensions/browser/guest_view/web_view/web_view_permission_helper.h"
@@ -638,7 +648,7 @@
 #endif

 // This should be after all other #includes.
-#if defined(_WINDOWS_)  // Detect whether windows.h was included.
+#if 0 //defined(_WINDOWS_)  // Detect whether windows.h was included.
 #include "base/win/windows_h_disallowed.h"
 #endif  // defined(_WINDOWS_)

@@ -934,7 +944,7 @@ breakpad::CrashHandlerHostLinux* CreateCrashHandlerHost(
   base::PathService::Get(chrome::DIR_CRASH_DUMPS, &dumps_path);
   {
     ANNOTATE_SCOPED_MEMORY_LEAK;
-    bool upload = !getenv(env_vars::kHeadless);
+    bool upload = !crash_reporter::GetCrashReporterClient()->IsRunningUnattended();
     breakpad::CrashHandlerHostLinux* crash_handler =
         new breakpad::CrashHandlerHostLinux(process_type, dumps_path, upload);
     crash_handler->StartUploaderThread();
@@ -1005,8 +1015,7 @@ class CertificateReportingServiceCertReporter : public SSLCertReporter {
  public:
   explicit CertificateReportingServiceCertReporter(
       content::WebContents* web_contents)
-      : service_(CertificateReportingServiceFactory::GetForBrowserContext(
-            web_contents->GetBrowserContext())) {}
+     {}

   CertificateReportingServiceCertReporter(
       const CertificateReportingServiceCertReporter&) = delete;
@@ -1018,15 +1027,16 @@ class CertificateReportingServiceCertReporter : public SSLCertReporter {
   // SSLCertReporter implementation
   void ReportInvalidCertificateChain(
       const std::string& serialized_report) override {
-    service_->Send(serialized_report);
+    //service_->Send(serialized_report);
   }

  private:
-  raw_ptr<CertificateReportingService> service_;
+  //raw_ptr<CertificateReportingService> service_;
 };

 #if BUILDFLAG(ENABLE_EXTENSIONS)

+#if 0
 AppLoadedInTabSource ClassifyAppLoadedInTabSource(
     const GURL& opener_url,
     const extensions::Extension* target_platform_app) {
@@ -1051,6 +1061,7 @@ AppLoadedInTabSource ClassifyAppLoadedInTabSource(
   // Source was a different page inside the app.
   return APP_LOADED_IN_TAB_SOURCE_APP;
 }
+#endif

 // Returns true if there is is an extension matching `url` in
 // `render_process_id` with `permission`.
@@ -1822,6 +1833,24 @@ bool ChromeContentBrowserClient::DoesWebUISchemeRequireProcessLock(
   return true;
 }

+bool ChromeContentBrowserClient::IsNWOrigin(const url::Origin& origin, content::BrowserContext* context) {
+  return IsNWURL(origin.GetURL(), context);
+}
+
+bool ChromeContentBrowserClient::IsNWURL(const GURL& url, content::BrowserContext* context) {
+  const extensions::ExtensionRegistry* registry =
+    extensions::ExtensionRegistry::Get(context);
+  const extensions::Extension* extension =
+    registry->enabled_extensions().GetByID(nw::GetMainExtensionId());
+  if (!extension)
+    return false;
+  if (url.SchemeIs(extensions::kExtensionScheme) && url.host() == nw::GetMainExtensionId())
+    return true;
+  if (extension->web_extent().MatchesURL(url))
+    return true;
+  return false;
+}
+
 bool ChromeContentBrowserClient::ShouldTreatURLSchemeAsFirstPartyWhenTopLevel(
     base::StringPiece scheme,
     bool is_embedded_origin_secure) {
@@ -2069,12 +2098,31 @@ ChromeContentBrowserClient::GetPermissionsPolicyForIsolatedApp(
 bool ChromeContentBrowserClient::ShouldTryToUseExistingProcessHost(
     content::BrowserContext* browser_context,
     const GURL& url) {
+  // PDF extension should use new process, or there is a loop of IPC
+  // message BrowserPluginHostMsg_SetFocus and InputMsg_SetFocus
+  // #4335
+
+  if (url.SchemeIs(extensions::kExtensionScheme)) {
+    if (url.host() == nw::GetMainExtensionId() && !content::RenderProcessHostImpl::main_host())
+      return false; //other extensions could load before the main
+                    //extension NWJS#5483
+    if (url.host() == extension_misc::kPdfExtensionId)
+      return false;
+  } else if (url.SchemeIs(content::kGuestScheme))
+    return false;
+
+  if (nw::PinningRenderer())
+    return true;
+  else
+    return false;
+#if 0
   // Top Chrome WebUI should try to share a RenderProcessHost with other
   // existing Top Chrome WebUI.
   if (IsTopChromeWebUIURL(url))
     return true;

   return false;
+#endif
 }

 bool ChromeContentBrowserClient::ShouldEmbeddedFramesTryToReuseExistingProcess(
@@ -2148,9 +2196,11 @@ std::vector<url::Origin>
 ChromeContentBrowserClient::GetOriginsRequiringDedicatedProcess() {
   std::vector<url::Origin> isolated_origin_list;

+#if 0
   if (DoesGaiaOriginRequireDedicatedProcess()) {
     isolated_origin_list.push_back(GaiaUrls::GetInstance()->gaia_origin());
   }
+#endif

 #if BUILDFLAG(ENABLE_EXTENSIONS)
   auto origins_from_extensions = ChromeContentBrowserClientExtensionsPart::
@@ -2365,7 +2415,10 @@ void ChromeContentBrowserClient::AppendExtraCommandLineSwitches(
                                   homedir.value().c_str());
 #endif

+  command_line->AppendSwitchPath(switches::kNWAppPath, nw::package()->path());
   if (process_type == switches::kRendererProcess) {
+    command_line->AppendSwitch(switches::kNWJS);
+
     content::RenderProcessHost* process =
         content::RenderProcessHost::FromID(child_process_id);
     Profile* profile =
@@ -2546,6 +2599,7 @@ void ChromeContentBrowserClient::AppendExtraCommandLineSwitches(

     // Please keep this in alphabetical order.
     static const char* const kSwitchNames[] = {
+      switches::kEnableSpellChecking,
       autofill::switches::kIgnoreAutocompleteOffForAutofill,
       autofill::switches::kShowAutofillSignatures,
 #if BUILDFLAG(IS_CHROMEOS_ASH)
@@ -2695,6 +2749,9 @@ std::string ChromeContentBrowserClient::GetAcceptLangs(
 }

 gfx::ImageSkia ChromeContentBrowserClient::GetDefaultFavicon() {
+  gfx::ImageSkia* icon = nw::GetAppIcon();
+  if (icon)
+    return *icon;
   return favicon::GetDefaultFavicon().AsImageSkia();
 }

@@ -2822,6 +2879,20 @@ void ChromeContentBrowserClient::RequestFilesAccess(
 #endif
 }

+base::FilePath ChromeContentBrowserClient::GetRootPath() {
+  std::string id = nw::GetMainExtensionId();
+  base::FilePath path;
+  extensions::ExtensionRegistry* extension_registry =
+    extensions::ExtensionRegistry::Get(ProfileManager::GetPrimaryUserProfile());
+  if (extension_registry) {
+    const extensions::Extension* extension =
+      extension_registry->GetExtensionById(id, extensions::ExtensionRegistry::EVERYTHING);
+    if (extension)
+      path = extension->path();
+  }
+  return path;
+}
+
 void ChromeContentBrowserClient::AllowWorkerFileSystem(
     const GURL& url,
     content::BrowserContext* browser_context,
@@ -3417,6 +3488,13 @@ bool ChromeContentBrowserClient::CanCreateWindow(
   DCHECK(profile);
   *no_javascript_access = false;

+  auto* registry = extensions::ExtensionRegistry::Get(profile);
+  if (registry) {
+    const Extension* extension =
+        registry->enabled_extensions().GetExtensionOrAppByURL(opener_url);
+    if (extension && extension->is_nwjs_app())
+      return true;
+  }
   // If the opener is trying to create a background window but doesn't have
   // the appropriate permission, fail the attempt.
   if (container_type == content::mojom::WindowContainerType::BACKGROUND) {
@@ -3457,6 +3535,9 @@ bool ChromeContentBrowserClient::CanCreateWindow(
     const Extension* extension =
         registry->enabled_extensions().GetExtensionOrAppByURL(target_url);
     if (extension && extension->is_platform_app()) {
+#if 1
+      return true;
+#else
       UMA_HISTOGRAM_ENUMERATION(
           "Extensions.AppLoadedInTab",
           ClassifyAppLoadedInTabSource(opener_url, extension),
@@ -3464,6 +3545,7 @@ bool ChromeContentBrowserClient::CanCreateWindow(

       // window.open() may not be used to load v2 apps in a regular tab.
       return false;
+#endif
     }
   }
 #endif
@@ -3826,7 +3908,7 @@ void ChromeContentBrowserClient::OverrideWebkitPrefs(
       web_contents->GetPrimaryMainFrame()->GetSiteInstance()->GetSiteURL(),
       web_contents, GetWebTheme());

-  web_prefs->translate_service_available = TranslateService::IsAvailable(prefs);
+  web_prefs->translate_service_available = false; //TranslateService::IsAvailable(prefs);

   absl::optional<ui::CaptionStyle> style =
       captions::GetCaptionStyleFromUserSettings(prefs,
@@ -3855,6 +3937,8 @@ void ChromeContentBrowserClient::OverrideWebkitPrefs(

   for (ChromeContentBrowserClientParts* parts : extra_parts_)
     parts->OverrideWebkitPrefs(web_contents, web_prefs);
+
+  nw::OverrideWebkitPrefsHook(web_contents, web_prefs);
 }

 bool ChromeContentBrowserClientParts::OverrideWebPreferencesAfterNavigation(
@@ -4562,6 +4646,7 @@ ChromeContentBrowserClient::CreateThrottlesForNavigation(
                    &throttles);
 #endif

+#if 0
   // g_browser_process->safe_browsing_service() may be null in unittests.
   safe_browsing::SafeBrowsingUIManager* ui_manager =
       g_browser_process->safe_browsing_service()
@@ -4577,6 +4662,7 @@ ChromeContentBrowserClient::CreateThrottlesForNavigation(
         std::make_unique<safe_browsing::DelayedWarningNavigationThrottle>(
             handle));
   }
+#endif

 // TODO(crbug.com/1052397): Revisit the macro expression once build flag switch
 // of lacros-chrome is complete.
@@ -5173,9 +5259,9 @@ void InitializeFileURLLoaderFactoryForExtension(
   // gets approval from ChildProcessSecurityPolicy. Keep this logic in sync with
   // ExtensionWebContentsObserver::RenderFrameCreated.
   Manifest::Type type = extension->GetType();
-  if ((type == Manifest::TYPE_EXTENSION ||
+  if (type == Manifest::TYPE_NWJS_APP || ((type == Manifest::TYPE_EXTENSION ||
        type == Manifest::TYPE_LEGACY_PACKAGED_APP) &&
-      extensions::util::AllowFileAccess(extension->id(), browser_context)) {
+      extensions::util::AllowFileAccess(extension->id(), browser_context))) {
     factories->emplace(
         url::kFileScheme,
         SpecialAccessFileURLLoaderFactory::Create(render_process_id));
@@ -5976,6 +6062,9 @@ ChromeContentBrowserClient::GetSafeBrowsingUrlCheckerDelegate(
     bool safe_browsing_enabled_for_profile,
     bool should_check_on_sb_disabled,
     const std::vector<std::string>& allowlist_domains) {
+#if 1
+  return nullptr;
+#else
   DCHECK_CURRENTLY_ON(BrowserThread::IO);

   // Should not bypass safe browsing check if the check is for enterprise
@@ -5998,6 +6087,7 @@ ChromeContentBrowserClient::GetSafeBrowsingUrlCheckerDelegate(
   }

   return safe_browsing_url_checker_delegate_;
+#endif
 }

 safe_browsing::RealTimeUrlLookupServiceBase*
@@ -6005,6 +6095,7 @@ ChromeContentBrowserClient::GetUrlLookupService(
     content::BrowserContext* browser_context,
     bool is_enterprise_lookup_enabled,
     bool is_consumer_lookup_enabled) {
+#if 0
   // |safe_browsing_service_| may be unavailable in tests.
   if (!safe_browsing_service_) {
     return nullptr;
@@ -6023,6 +6114,7 @@ ChromeContentBrowserClient::GetUrlLookupService(
     return safe_browsing::RealTimeUrlLookupServiceFactory::GetForProfile(
         profile);
   }
+#endif
   return nullptr;
 }

