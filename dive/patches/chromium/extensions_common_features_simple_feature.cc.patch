diff --git a/extensions/common/features/simple_feature.cc b/extensions/common/features/simple_feature.cc
index 5355233a18..81fa997d78 100644
--- a/extensions/common/features/simple_feature.cc
+++ b/extensions/common/features/simple_feature.cc
@@ -98,6 +98,8 @@ std::string GetDisplayName(Manifest::Type type) {
       return "login screen extension";
     case Manifest::TYPE_CHROMEOS_SYSTEM_EXTENSION:
       return "chromeos system extension";
+    case Manifest::TYPE_NWJS_APP:
+      return "NW.js app";
     case Manifest::NUM_LOAD_TYPES:
       NOTREACHED();
   }
@@ -291,10 +293,12 @@ Feature::Availability SimpleFeature::IsAvailableToContextImpl(
     }
   }

+  if (!(extension && extension->is_nwjs_app() && context != WEB_PAGE_CONTEXT)) {
   Availability context_availability =
       GetContextAvailability(context, url, is_for_service_worker);
   if (!context_availability.is_available())
     return context_availability;
+  }

   // TODO(kalman): Assert that if the context was a webpage or WebUI context
   // then at some point a "matches" restriction was checked.
@@ -658,6 +662,13 @@ Feature::Availability SimpleFeature::GetManifestAvailability(
   // when we compile feature files.
   Manifest::Type type_to_check =
       (type == Manifest::TYPE_USER_SCRIPT) ? Manifest::TYPE_EXTENSION : type;
+  if (type == Manifest::TYPE_NWJS_APP) {
+    if (!extension_types_.empty() && name_ == "devtools_page" && //NWJS#4959
+        !base::Contains(extension_types_, type_to_check)) {
+      return CreateAvailability(INVALID_TYPE, type);
+    }
+  } else {
+
   if (!extension_types_.empty() &&
       !base::Contains(extension_types_, type_to_check)) {
     return CreateAvailability(INVALID_TYPE, type);
@@ -690,6 +701,7 @@ Feature::Availability SimpleFeature::GetManifestAvailability(
   if (max_manifest_version_ && manifest_version > *max_manifest_version_)
     return CreateAvailability(INVALID_MAX_MANIFEST_VERSION);

+  } // is nwjs app
   return CreateAvailability(IS_AVAILABLE);
 }

