diff --git a/chrome/app/chrome_main_delegate.cc b/chrome/app/chrome_main_delegate.cc
index c698f4dabb..8a10444fbd 100644
--- a/chrome/app/chrome_main_delegate.cc
+++ b/chrome/app/chrome_main_delegate.cc
@@ -2,8 +2,12 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.

+#include "chrome/common/chrome_constants.h"
 #include "chrome/app/chrome_main_delegate.h"

+#include "chrome/chrome_elf/chrome_elf_main.h"
+#include "base/files/file_util.h"
+
 #include <stddef.h>

 #include <string>
@@ -89,6 +93,7 @@
 #include "ui/base/resource/resource_bundle.h"
 #include "ui/base/ui_base_switches.h"

+#include "content/nw/src/nw_base.h"
 #if BUILDFLAG(IS_WIN)
 #include <malloc.h>

@@ -213,6 +218,16 @@
 #include "ui/base/resource/data_pack_with_resource_sharing_lacros.h"
 #endif

+#include "third_party/node-nw/src/node_webkit.h"
+#include "third_party/zlib/google/zip_reader.h"
+#include "base/native_library.h"
+#include "base/strings/utf_string_conversions.h"
+#if defined(OS_MAC)
+#include "base/mac/bundle_locations.h"
+#include "base/strings/sys_string_conversions.h"
+#endif
+
+
 base::LazyInstance<ChromeContentGpuClient>::DestructorAtExit
     g_chrome_content_gpu_client = LAZY_INSTANCE_INITIALIZER;
 base::LazyInstance<ChromeContentRendererClient>::DestructorAtExit
@@ -229,6 +244,13 @@ const char* const ChromeMainDelegate::kNonWildcardDomainNonPortSchemes[] = {
 const size_t ChromeMainDelegate::kNonWildcardDomainNonPortSchemesSize =
     std::size(kNonWildcardDomainNonPortSchemes);

+#if defined(COMPONENT_BUILD)
+CONTENT_EXPORT NodeStartFn g_node_start_fn;
+#else
+extern NodeStartFn g_node_start_fn;
+#endif
+SetBlobPathFn g_set_blob_path_fn = nullptr;
+
 namespace {

 #if BUILDFLAG(IS_CHROMEOS_LACROS)
@@ -482,7 +504,7 @@ struct MainFunction {

 // Initializes the user data dir. Must be called before InitializeLocalState().
 void InitializeUserDataDir(base::CommandLine* command_line) {
-#if BUILDFLAG(IS_WIN)
+#if 0
   // Reach out to chrome_elf for the truth on the user data directory.
   // Note that in tests, this links to chrome_elf_test_stubs.
   wchar_t user_data_dir_buf[MAX_PATH], invalid_user_data_dir_buf[MAX_PATH];
@@ -519,10 +541,15 @@ void InitializeUserDataDir(base::CommandLine* command_line) {
     }
   }
 #endif  // BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS)
-#if BUILDFLAG(IS_MAC)
+#if BUILDFLAG(IS_MAC) || BUILDFLAG(IS_WIN)
   policy::path_parser::CheckUserDataDirPolicy(&user_data_dir);
 #endif  // BUILDFLAG(IS_MAC)

+  // On Windows, trailing separators leave Chrome in a bad state.
+  // See crbug.com/464616.
+  if (user_data_dir.EndsWithSeparator())
+    user_data_dir = user_data_dir.StripTrailingSeparators();
+
   const bool specified_directory_was_invalid =
       !user_data_dir.empty() &&
       !base::PathService::OverrideAndCreateIfNeeded(chrome::DIR_USER_DATA,
@@ -553,7 +580,7 @@ void InitializeUserDataDir(base::CommandLine* command_line) {

   // Append the fallback user data directory to the commandline. Otherwise,
   // child or service processes will attempt to use the invalid directory.
-  if (specified_directory_was_invalid)
+  //if (specified_directory_was_invalid)
     command_line->AppendSwitchPath(switches::kUserDataDir, user_data_dir);
 #endif  // BUILDFLAG(IS_WIN)
 }
@@ -847,7 +874,7 @@ absl::optional<int> ChromeMainDelegate::BasicStartupComplete() {
   ash::BootTimesRecorder::Get()->SaveChromeMainStats();
 #endif

-  const base::CommandLine& command_line =
+  base::CommandLine& command_line =
       *base::CommandLine::ForCurrentProcess();

   // Only allow disabling web security via the command-line flag if the user has
@@ -889,6 +916,37 @@ absl::optional<int> ChromeMainDelegate::BasicStartupComplete() {

   content::Profiling::ProcessStarted();

+  const base::CommandLine::StringVector& args = command_line.GetArgs();
+  if (args.size() > 0) {
+    zip::ZipReader reader;
+    base::FilePath fp(args[0]);
+    //LOG(WARNING) << "final extension: " << fp.FinalExtension();
+    if (!command_line.HasSwitch(switches::kProcessType) && fp.FinalExtension() == FILE_PATH_LITERAL(".js") &&
+        base::PathExists(fp) && !base::DirectoryExists(fp) && !reader.Open(fp)) {
+      base::NativeLibraryLoadError error;
+#if defined(OS_MAC)
+      base::FilePath node_dll_path = base::mac::FrameworkBundlePath().Append(base::FilePath::FromUTF8Unsafe(base::GetNativeLibraryName("node")));
+      base::ScopedCFTypeRef<CFStringRef> natives_file_name(base::SysUTF8ToCFStringRef(V8_CONTEXT_SNAPSHOT_FILENAME));
+      std::string blob_path = base::mac::PathForFrameworkBundleResource(natives_file_name).AsUTF8Unsafe();
+#else
+      base::FilePath node_dll_path = base::FilePath::FromUTF8Unsafe(base::GetNativeLibraryName("node"));
+#endif
+      base::NativeLibrary node_dll = base::LoadNativeLibrary(node_dll_path, &error);
+      if(!node_dll)
+        LOG(FATAL) << "Failed to load node library (error: " << error.ToString() << ")";
+      else {
+#if defined(OS_MAC)
+        g_set_blob_path_fn = (SetBlobPathFn)base::GetFunctionPointerFromNativeLibrary(node_dll, "g_set_blob_path");
+        g_set_blob_path_fn(blob_path.c_str());
+#endif
+        g_node_start_fn = (NodeStartFn)base::GetFunctionPointerFromNativeLibrary(node_dll, "g_node_start");
+        return g_node_start_fn(command_line.argc0(), command_line.argv0());
+      }
+      return 0;
+    }
+  }
+
+
   // Setup tracing sampler profiler as early as possible at startup if needed.
   // We pass in CreateCoreUnwindersFactory here since it lives in the chrome/
   // layer while TracingSamplerProfiler is outside of chrome/.
@@ -1056,6 +1114,26 @@ absl::optional<int> ChromeMainDelegate::BasicStartupComplete() {
   // partially-initialized, which the TLS object is supposed to protect again.
   heap_profiling::InitTLSSlot();

+  std::wstring product_name, product_version;
+  std::string report_url;
+
+  nw::InitNWPackage();
+  std::string name = nw::package()->GetName();
+  std::string version;
+  product_name = std::wstring(name.begin(), name.end());
+  std::string* str = nw::package()->root()->FindString("version");
+  if (str)
+    version = *str;
+  product_version = std::wstring(version.begin(), version.end());
+#if defined(OS_WIN)
+  SignalInitializeCrashReporting(&product_name, &product_version);
+  str = nw::package()->root()->FindString("crash_report_url");
+  if (str) {
+    report_url = *str;
+    crash_reporter::CrashReporterClient* client = (crash_reporter::CrashReporterClient*)ElfGetReporterClient();
+    client->SetUploadDump(true);
+  }
+#endif
   return absl::nullopt;
 }

@@ -1130,7 +1208,39 @@ void ChromeMainDelegate::PreSandboxStartup() {
   ChromeCrashReporterClient::Create();
 #endif

+  std::string report_url;
+  std::string* str = nw::package()->root()->FindString("crash_report_url");
+  if (str) {
+    report_url = *str;
+#if !defined(OS_WIN)
+    crash_reporter::CrashReporterClient* client = crash_reporter::GetCrashReporterClient();
+    client->SetUploadDump(true);
+    client->product_name_ = nw::package()->GetName();
+    str = nw::package()->root()->FindString("version");
+    if (str)
+      client->product_version_ = *str;
+#endif
+  }
+
 #if BUILDFLAG(IS_MAC)
+  // On the Mac, the child executable lives at a predefined location within
+  // the app bundle's versioned directory.
+  std::string product_string;
+  str = nw::package()->root()->FindString("product_string");
+  if (str) {
+    product_string = *str;
+    std::string helperProcessExecutablePath = (product_string + " Helper.app/Contents/MacOS/" + product_string + " Helper");
+    base::PathService::Override(content::CHILD_PROCESS_EXE,
+                                chrome::GetFrameworkBundlePath()
+                                .Append("Helpers")
+                                .Append(helperProcessExecutablePath));
+  }else{
+    base::PathService::Override(content::CHILD_PROCESS_EXE,
+                                chrome::GetFrameworkBundlePath()
+                                .Append("Helpers")
+                                .Append(chrome::kHelperProcessExecutablePath));
+  }
+
   InitMacCrashReporter(command_line, process_type);
   SetUpInstallerPreferences(command_line);
 #endif
@@ -1205,7 +1315,7 @@ void ChromeMainDelegate::PreSandboxStartup() {
   }
 #endif  // BUILDFLAG(IS_CHROMEOS_LACROS)

-  // Register component_updater PathProvider after DIR_USER_DATA overridden by
+#if 1
   // command line flags. Maybe move the chrome PathProvider down here also?
   int alt_preinstalled_components_dir =
 #if BUILDFLAG(IS_CHROMEOS_ASH)
@@ -1216,6 +1326,7 @@ void ChromeMainDelegate::PreSandboxStartup() {
   component_updater::RegisterPathProvider(chrome::DIR_COMPONENTS,
                                           alt_preinstalled_components_dir,
                                           chrome::DIR_USER_DATA);
+#endif

 #if !BUILDFLAG(IS_ANDROID) && !BUILDFLAG(IS_WIN)
   // Android does InitLogging when library is loaded. Skip here.
@@ -1376,6 +1487,13 @@ void ChromeMainDelegate::PreSandboxStartup() {
   // line for crash reporting.
   crash_keys::SetCrashKeysFromCommandLine(command_line);

+#if 1 //!defined(OS_WIN)
+  if (!report_url.empty()) {
+    GURL url(report_url);
+    chrome_content_client_.SetNWReportURL(url);
+  }
+#endif
+
 #if BUILDFLAG(ENABLE_PDF)
   MaybePatchGdiGetFontData();
 #endif
