diff --git a/chrome/browser/ui/window_sizer/window_sizer.cc b/chrome/browser/ui/window_sizer/window_sizer.cc
index 57ddce8fc8..14a829bdb5 100644
--- a/chrome/browser/ui/window_sizer/window_sizer.cc
+++ b/chrome/browser/ui/window_sizer/window_sizer.cc
@@ -1,10 +1,11 @@
 // Copyright (c) 2012 The Chromium Authors. All rights reserved.
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
-
+#pragma clang diagnostic ignored "-Wunreachable-code"
 #include "chrome/browser/ui/window_sizer/window_sizer.h"

 #include <algorithm>
+#include "content/nw/src/nw_base.h"
 #include <utility>

 #include "base/command_line.h"
@@ -53,6 +54,8 @@ class DefaultStateProvider : public WindowSizer::StateProvider {
     if (!browser_ || !browser_->profile()->GetPrefs())
       return false;

+    if (browser_->is_type_popup() && browser_->windows_key().empty())
+      return false;
     const base::Value::Dict* pref =
         chrome::GetWindowPlacementDictionaryReadOnly(
             chrome::GetWindowName(browser_), browser_->profile()->GetPrefs());
@@ -62,6 +65,8 @@ class DefaultStateProvider : public WindowSizer::StateProvider {
         RectFromPrefixedPref(pref, "work_area_");
     absl::optional<bool> maximized =
         pref ? pref->FindBool("maximized") : absl::nullopt;
+    absl::optional<bool> fullscreen =
+        pref ? pref->FindBool("fullscreen") : absl::nullopt;

     if (!pref_bounds || !maximized)
       return false;
@@ -71,6 +76,8 @@ class DefaultStateProvider : public WindowSizer::StateProvider {
       *work_area = pref_area.value();
     if (*show_state == ui::SHOW_STATE_DEFAULT && maximized.value())
       *show_state = ui::SHOW_STATE_MAXIMIZED;
+    if (*show_state == ui::SHOW_STATE_DEFAULT && fullscreen && fullscreen.value())
+      *show_state = ui::SHOW_STATE_FULLSCREEN;

     return true;
   }
@@ -163,7 +170,7 @@ WindowSizer::WindowSizer(std::unique_ptr<StateProvider> state_provider,
 WindowSizer::~WindowSizer() = default;

 // static
-void WindowSizer::GetBrowserWindowBoundsAndShowState(
+bool WindowSizer::GetBrowserWindowBoundsAndShowState(
     const gfx::Rect& specified_bounds,
     const Browser* browser,
     gfx::Rect* window_bounds,
@@ -176,7 +183,7 @@ void WindowSizer::GetBrowserWindowBoundsAndShowState(
 #if !BUILDFLAG(IS_LINUX)
 // Linux has its own implementation, see WindowSizerLinux.
 // static
-void WindowSizer::GetBrowserWindowBoundsAndShowState(
+bool WindowSizer::GetBrowserWindowBoundsAndShowState(
     std::unique_ptr<StateProvider> state_provider,
     const gfx::Rect& specified_bounds,
     const Browser* browser,
@@ -192,26 +199,34 @@ void WindowSizer::GetBrowserWindowBoundsAndShowState(
   // Pre-populate the window state with our default.
   *show_state = GetWindowDefaultShowState(browser);
   *bounds = specified_bounds;
-  sizer.DetermineWindowBoundsAndShowState(specified_bounds, bounds, show_state);
+  return sizer.DetermineWindowBoundsAndShowState(specified_bounds, bounds, show_state);
 }
 #endif  // !BUILDFLAG(IS_LINUX)

-void WindowSizer::DetermineWindowBoundsAndShowState(
+bool WindowSizer::DetermineWindowBoundsAndShowState(
     const gfx::Rect& specified_bounds,
     gfx::Rect* bounds,
     ui::WindowShowState* show_state) {
-  if (bounds->IsEmpty()) {
+  // In upstream, non empty case is only used in chrome tests, so we ignore it.
+  // In NW, the non empty value is the API parameter passed by browser->override_bounds()
+  // Use this strategy as the central place to determine window size
+  // priority: saved > API parameter > default in manifest > default value
+  if (true || bounds->IsEmpty()) {
     // See if there's last active window's placement information.
     if (GetLastActiveWindowBounds(bounds, show_state))
-      return;
+      return false;
+    gfx::Rect saved;
     // See if there's saved placement information.
-    if (GetSavedWindowBounds(bounds, show_state))
-      return;
-
+    if (GetSavedWindowBounds(&saved, show_state)) {
+      *bounds = saved;
+      return true;
+    }
+    if (!bounds->IsEmpty())
+      return false;
     // No saved placement, figure out some sensible default size based on
     // the user's screen size.
     *bounds = GetDefaultWindowBounds(GetDisplayForNewWindow());
-    return;
+    return false;
   }

   // In case that there was a bound given we need to make sure that it is
@@ -227,6 +242,7 @@ void WindowSizer::DetermineWindowBoundsAndShowState(

   // Resize so that it fits.
   bounds->AdjustToFit(work_area);
+  return false;
 }

 void WindowSizer::AdjustWorkAreaForPlatform(gfx::Rect& work_area) {}
@@ -265,6 +281,15 @@ gfx::Rect WindowSizer::GetDefaultWindowBounds(
     const display::Display& display) const {
   gfx::Rect work_area = display.work_area();

+  int default_width = 800;
+  int default_height = 600;
+  nw::Package* package = nw::package();
+  if (package && package->window()) {
+    default_width = package->window()->FindInt("width").value_or(800);
+    default_height = package->window()->FindInt("height").value_or(600);
+  }
+
+#if 0
   // The default size is either some reasonably wide width, or if the work
   // area is narrower, then the work area width less some aesthetic padding.
   int default_width = std::min(work_area.width() - 2 * kWindowTilePixels,
@@ -292,9 +317,10 @@ gfx::Rect WindowSizer::GetDefaultWindowBounds(
         1.5 * kWindowTilePixels);
   }
 #endif  // !BUILDFLAG(IS_MAC)
+#endif
   return gfx::Rect(kWindowTilePixels + work_area.x(),
-                   kWindowTilePixels + work_area.y(), default_width,
-                   default_height);
+                   kWindowTilePixels + work_area.y(),
+                   default_width, default_height);
 }

 void WindowSizer::AdjustBoundsToBeVisibleOnDisplay(
