diff --git a/chrome/browser/ui/views/apps/glass_app_window_frame_view_win.cc b/chrome/browser/ui/views/apps/glass_app_window_frame_view_win.cc
index 1b37d06e38..b879b39644 100644
--- a/chrome/browser/ui/views/apps/glass_app_window_frame_view_win.cc
+++ b/chrome/browser/ui/views/apps/glass_app_window_frame_view_win.cc
@@ -63,6 +63,9 @@ gfx::Insets GlassAppWindowFrameViewWin::GetClientAreaInsets(
 }

 gfx::Rect GlassAppWindowFrameViewWin::GetBoundsForClientView() const {
+#if 1
+  return bounds();
+#else
   if (widget_->IsFullscreen())
     return bounds();

@@ -71,6 +74,7 @@ gfx::Rect GlassAppWindowFrameViewWin::GetBoundsForClientView() const {
                    insets.top(),
                    std::max(0, width() - insets.left() - insets.right()),
                    std::max(0, height() - insets.top() - insets.bottom()));
+#endif
 }

 gfx::Rect GlassAppWindowFrameViewWin::GetWindowBoundsForClientBounds(
@@ -98,6 +102,11 @@ int GlassAppWindowFrameViewWin::NonClientHitTest(const gfx::Point& point) {
   if (!bounds().Contains(point))
     return HTNOWHERE;

+  int client_component = widget_->client_view()->NonClientHitTest(point);
+  if (client_component != HTNOWHERE)
+    return client_component;
+
+
   // Check the frame first, as we allow a small area overlapping the contents
   // to be used for resize handles.
   bool can_ever_resize = widget_->widget_delegate()
@@ -113,10 +122,6 @@ int GlassAppWindowFrameViewWin::NonClientHitTest(const gfx::Point& point) {
   if (frame_component != HTNOWHERE)
     return frame_component;

-  int client_component = widget_->client_view()->NonClientHitTest(point);
-  if (client_component != HTNOWHERE)
-    return client_component;
-
   // Caption is a safe default.
   return HTCAPTION;
 }
