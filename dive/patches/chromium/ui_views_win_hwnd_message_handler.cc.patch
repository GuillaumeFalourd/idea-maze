diff --git a/ui/views/win/hwnd_message_handler.cc b/ui/views/win/hwnd_message_handler.cc
index 29e812d41d..82e6542626 100644
--- a/ui/views/win/hwnd_message_handler.cc
+++ b/ui/views/win/hwnd_message_handler.cc
@@ -399,6 +399,8 @@ base::LazyInstance<HWNDMessageHandler::FullscreenWindowMonitorMap>::
 LONG HWNDMessageHandler::last_touch_or_pen_message_time_ = 0;
 bool HWNDMessageHandler::is_pen_active_in_client_area_ = false;

+#define TRANSPARENCY(original, addition) content::g_support_transparency ? original addition : original
+
 HWNDMessageHandler::HWNDMessageHandler(HWNDMessageHandlerDelegate* delegate,
                                        const std::string& debugging_id)
     : WindowImpl(debugging_id),
@@ -450,6 +452,16 @@ void HWNDMessageHandler::Init(HWND parent,

   // Create the window.
   WindowImpl::Init(parent, bounds);
+  if (content::g_support_transparency && is_translucent_ && !content::g_force_cpu_draw) {
+    //WS_CAPTION style is somehow applied, during window creation, needs to update the style
+	  set_window_style((DWORD)GetWindowLong(hwnd(), GWL_STYLE));
+    //copied from WindowImpl::Init, see "First nccalcszie" comment
+    if (window_style() & WS_CAPTION) {
+      SetWindowPos(hwnd(), NULL, 0, 0, 0, 0,
+        SWP_FRAMECHANGED | SWP_NOMOVE | SWP_NOSIZE |
+        SWP_NOZORDER | SWP_NOACTIVATE | SWP_NOREDRAW);
+    }
+  }

   if (!called_enable_non_client_dpi_scaling_ && delegate_->HasFrame() &&
       base::win::IsProcessPerMonitorDpiAware()) {
@@ -954,13 +966,16 @@ void HWNDMessageHandler::SetWindowIcons(const gfx::ImageSkia& window_icon,
                                         const gfx::ImageSkia& app_icon) {
   if (!window_icon.isNull()) {
     base::win::ScopedHICON previous_icon = std::move(window_icon_);
-    window_icon_ = IconUtil::CreateHICONFromSkBitmap(*window_icon.bitmap());
+    window_icon_ =
+        IconUtil::CreateHICONFromSkBitmapSizedTo(*window_icon.bitmap(),
+          GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON));
     SendMessage(hwnd(), WM_SETICON, ICON_SMALL,
                 reinterpret_cast<LPARAM>(window_icon_.get()));
   }
   if (!app_icon.isNull()) {
     base::win::ScopedHICON previous_icon = std::move(app_icon_);
-    app_icon_ = IconUtil::CreateHICONFromSkBitmap(*app_icon.bitmap());
+    app_icon_ = IconUtil::CreateHICONFromSkBitmapSizedTo(*app_icon.bitmap(),
+          GetSystemMetrics(SM_CXICON), GetSystemMetrics(SM_CYICON));
     SendMessage(hwnd(), WM_SETICON, ICON_BIG,
                 reinterpret_cast<LPARAM>(app_icon_.get()));
   }
@@ -1022,7 +1037,7 @@ void HWNDMessageHandler::SizeConstraintsChanged() {

   // Windows cannot have WS_THICKFRAME set if translucent.
   // See CalculateWindowStylesFromInitParams().
-  if (delegate_->CanResize() && !is_translucent_) {
+  if (delegate_->CanResize() && (content::g_support_transparency || !is_translucent_)) {
     style |= WS_THICKFRAME | WS_MAXIMIZEBOX;
     if (!delegate_->CanMaximize())
       style &= ~WS_MAXIMIZEBOX;
@@ -1034,6 +1049,10 @@ void HWNDMessageHandler::SizeConstraintsChanged() {
   } else {
     style &= ~WS_MINIMIZEBOX;
   }
+  if (content::g_support_transparency && is_translucent_ && !content::g_force_cpu_draw) {
+    //WS_CAPTION needs to be removed on transparent window, or else the Title bar will be rendered
+    style &= ~WS_CAPTION;
+  }
   SetWindowLong(hwnd(), GWL_STYLE, style);
 }

@@ -1523,6 +1542,10 @@ bool HWNDMessageHandler::GetClientAreaInsets(gfx::Insets* insets,
     if (!delegate_->HasFrame())
       frame_thickness -= 1;
     *insets = gfx::Insets(frame_thickness);
+    if (content::g_force_cpu_draw && is_translucent_ && !delegate_->HasFrame()) {
+      //part of maximize_hack code
+      insets->set_top_bottom(0, -1).set_left_right(0, -1);
+    }
     return true;
   }

@@ -1539,7 +1562,7 @@ void HWNDMessageHandler::ResetWindowRegion(bool force, bool redraw) {
   // allow for a custom hit mask.
   if (!is_translucent_ && !custom_window_region_.is_valid() &&
       (IsFrameSystemDrawn() || !delegate_->HasNonClientView())) {
-    if (force)
+    if (force || content::g_force_cpu_draw)
       SetWindowRgn(hwnd(), nullptr, redraw);
     return;
   }
@@ -1564,6 +1587,10 @@ void HWNDMessageHandler::ResetWindowRegion(bool force, bool redraw) {
     RECT work_rect = mi.rcWork;
     OffsetRect(&work_rect, -window_rect.left, -window_rect.top);
     new_region.reset(CreateRectRgnIndirect(&work_rect));
+  } else if (content::g_support_transparency && is_translucent_) {
+    RECT work_rect = window_rect;
+    OffsetRect(&work_rect, -window_rect.left, -window_rect.top);
+    new_region.reset(CreateRectRgnIndirect(&work_rect));
   } else {
     SkPath window_mask;
     delegate_->GetWindowMask(gfx::Size(window_rect.right - window_rect.left,
@@ -1715,7 +1742,7 @@ LRESULT HWNDMessageHandler::OnCreate(CREATESTRUCT* create_struct) {
   SendMessage(hwnd(), WM_CHANGEUISTATE, MAKELPARAM(UIS_CLEAR, UISF_HIDEFOCUS),
               0);

-  if (!delegate_->HasFrame()) {
+  if (TRANSPARENCY(!delegate_->HasFrame(), && !(is_translucent_))) {
     SetWindowLong(hwnd(), GWL_STYLE,
                   GetWindowLong(hwnd(), GWL_STYLE) & ~WS_CAPTION);
     SendFrameChanged();
@@ -1902,15 +1929,17 @@ void HWNDMessageHandler::OnGetMinMaxInfo(MINMAXINFO* minmax_info) {
   if (delegate_->WidgetSizeIsClientSize()) {
     RECT client_rect, window_rect;
     GetClientRect(hwnd(), &client_rect);
-    GetWindowRect(hwnd(), &window_rect);
-    CR_DEFLATE_RECT(&window_rect, &client_rect);
-    min_window_size.Enlarge(window_rect.right - window_rect.left,
-                            window_rect.bottom - window_rect.top);
-    // Either axis may be zero, so enlarge them independently.
-    if (max_window_size.width())
-      max_window_size.Enlarge(window_rect.right - window_rect.left, 0);
-    if (max_window_size.height())
-      max_window_size.Enlarge(0, window_rect.bottom - window_rect.top);
+	if (client_rect.right > client_rect.left) {
+		GetWindowRect(hwnd(), &window_rect);
+		CR_DEFLATE_RECT(&window_rect, &client_rect);
+		min_window_size.Enlarge(window_rect.right - window_rect.left,
+			window_rect.bottom - window_rect.top);
+		// Either axis may be zero, so enlarge them independently.
+		if (max_window_size.width())
+			max_window_size.Enlarge(window_rect.right - window_rect.left, 0);
+		if (max_window_size.height())
+			max_window_size.Enlarge(0, window_rect.bottom - window_rect.top);
+	}
   }
   minmax_info->ptMinTrackSize.x = min_window_size.width();
   minmax_info->ptMinTrackSize.y = min_window_size.height();
@@ -2296,9 +2325,11 @@ LRESULT HWNDMessageHandler::OnNCCalcSize(BOOL mode, LPARAM l_param) {
     }
   }

+  const LONG noTitleBar = (is_translucent_) && !delegate_->HasFrame();
   gfx::Insets insets;
   bool got_insets = GetClientAreaInsets(&insets, monitor);
-  if (!got_insets && !IsFullscreen() && !(mode && !delegate_->HasFrame())) {
+  if (TRANSPARENCY(!got_insets && !IsFullscreen() &&
+                   !(mode && !delegate_->HasFrame()), && !noTitleBar)) {
     SetMsgHandled(FALSE);
     return 0;
   }
@@ -2684,6 +2715,8 @@ void HWNDMessageHandler::OnSize(UINT param, const gfx::Size& size) {
   // ResetWindowRegion is going to trigger WM_NCPAINT. By doing it after we've
   // invoked OnSize we ensure the RootView has been laid out.
   ResetWindowRegion(false, true);
+  if (delegate_->ShouldHandleOnSize())
+    delegate_->HandleSize(param, size);
 }

 void HWNDMessageHandler::OnSizing(UINT param, RECT* rect) {
@@ -2699,6 +2732,15 @@ void HWNDMessageHandler::OnSizing(UINT param, RECT* rect) {
   *rect = window_rect.ToRECT();
 }

+void HWNDMessageHandler::OnStyleChanging(UINT nStyleType, LPSTYLESTRUCT lpStyleStruct) {
+  if (!content::g_support_transparency)
+    return;
+  if (nStyleType == (UINT)GWL_EXSTYLE)
+    set_window_ex_style(lpStyleStruct->styleNew);
+  else if (nStyleType == (UINT)GWL_STYLE)
+    set_window_style(lpStyleStruct->styleNew);
+}
+
 void HWNDMessageHandler::OnSysCommand(UINT notification_code,
                                       const gfx::Point& point) {
   // Windows uses the 4 lower order bits of |notification_code| for type-
@@ -2932,12 +2974,13 @@ void HWNDMessageHandler::OnWindowPosChanging(WINDOWPOS* window_pos) {
           expected_maximized_bounds.Inset(
               gfx::ScaleToCeiledInsets(client_area_insets, -1));
       }
+      const bool maximize_hack = content::g_force_cpu_draw && is_translucent_;
       // Sometimes Windows incorrectly changes bounds of maximized windows after
       // attaching or detaching additional displays. In this case user can see
       // non-client area of the window (that should be hidden in normal case).
       // We should restore window position if problem occurs.
       const bool incorrect_maximized_bounds =
-          IsMaximized() && have_new_window_rect &&
+          IsMaximized() && (maximize_hack || have_new_window_rect) &&
           (expected_maximized_bounds.x() != window_pos->x ||
            expected_maximized_bounds.y() != window_pos->y ||
            expected_maximized_bounds.width() != window_pos->cx ||
@@ -2985,7 +3028,7 @@ void HWNDMessageHandler::OnWindowPosChanging(WINDOWPOS* window_pos) {
         // Now ignore all immediately-following SetWindowPos() changes.  Windows
         // likes to (incorrectly) recalculate what our position/size should be
         // and send us further updates.
-        ignore_window_pos_changes_ = true;
+        ignore_window_pos_changes_ = !maximize_hack;
         base::ThreadTaskRunnerHandle::Get()->PostTask(
             FROM_HERE,
             base::BindOnce(&HWNDMessageHandler::StopIgnoringPosChanges,
@@ -3482,6 +3525,11 @@ bool HWNDMessageHandler::IsSynthesizedMouseMessage(unsigned int message,

 void HWNDMessageHandler::PerformDwmTransition() {
   dwm_transition_desired_ = false;
+  if (content::g_support_transparency && !content::g_force_cpu_draw && is_translucent_) {
+    const int im = ui::win::IsAeroGlassEnabled() ? -1 : 0;
+    MARGINS m = { im, im, im, im };
+    DwmExtendFrameIntoClientArea(hwnd(), &m);
+  }

   UpdateDwmNcRenderingPolicy();
   // Don't redraw the window here, because we need to hide and show the window
@@ -3493,7 +3541,7 @@ void HWNDMessageHandler::PerformDwmTransition() {
   // composition state changes.
   UpdateDwmFrame();

-  if (IsVisible() && IsFrameSystemDrawn()) {
+  if (IsVisible() && IsFrameSystemDrawn() && !content::g_force_cpu_draw) {
     // For some reason, we need to hide the window after we change from a custom
     // frame to a native frame.  If we don't, the client area will be filled
     // with black.  This seems to be related to an interaction between DWM and
@@ -3633,6 +3681,11 @@ bool HWNDMessageHandler::HandleMouseInputForCaption(unsigned int message,
   return handled;
 }

+void HWNDMessageHandler::SetPosition(const gfx::Point& pos_in_pixels) {
+  SetWindowPos(hwnd(), nullptr, pos_in_pixels.x(), pos_in_pixels.y(),
+    0, 0, SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOSIZE);
+}
+
 void HWNDMessageHandler::SetBoundsInternal(const gfx::Rect& bounds_in_pixels,
                                            bool force_size_changed) {
   gfx::Size old_size = GetClientAreaBounds().size();
