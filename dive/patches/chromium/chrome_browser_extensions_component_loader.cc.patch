diff --git a/chrome/browser/extensions/component_loader.cc b/chrome/browser/extensions/component_loader.cc
index a51bef22e3..a14f0fa3fb 100644
--- a/chrome/browser/extensions/component_loader.cc
+++ b/chrome/browser/extensions/component_loader.cc
@@ -5,6 +5,8 @@
 #include "chrome/browser/extensions/component_loader.h"

 #include <string>
+#include "content/public/common/content_features.h"
+#include "base/strings/utf_string_conversions.h"

 #include "ash/constants/ash_features.h"
 #include "ash/constants/ash_pref_names.h"
@@ -304,6 +306,18 @@ void ComponentLoader::Remove(const std::string& id) {
   }
 }

+std::string ComponentLoader::GetExtensionID(
+                                            int manifest_resource_id,
+                                            const base::FilePath& root_directory) {
+  std::unique_ptr<base::DictionaryValue> manifest =
+    ParseManifest(ui::ResourceBundle::GetSharedInstance().GetRawDataResource(
+                                                                         manifest_resource_id));
+  if (!manifest)
+    return std::string();
+
+  return GenerateId(manifest.get(), root_directory);
+}
+
 bool ComponentLoader::Exists(const std::string& id) const {
   for (const auto& component_extension : component_extensions_) {
     if (component_extension.extension_id == id)
@@ -425,6 +439,7 @@ void ComponentLoader::EnableBackgroundExtensionsForTesting() {

 void ComponentLoader::AddDefaultComponentExtensions(
     bool skip_session_components) {
+#if 0
   // Do not add component extensions that have background pages here -- add them
   // to AddDefaultComponentExtensionsWithBackgroundPages.
 #if BUILDFLAG(IS_CHROMEOS_ASH)
@@ -447,13 +462,49 @@ void ComponentLoader::AddDefaultComponentExtensions(
     if (crosapi::browser_util::IsAshWebBrowserEnabled())
       AddChromeApp();
 #endif  // BUILDFLAG(IS_CHROMEOS_ASH)
+  }
+
+#endif
+
+  AddDefaultComponentExtensionsWithBackgroundPages(skip_session_components);
 #if BUILDFLAG(ENABLE_PDF)
     Add(pdf_extension_util::GetManifest(),
         base::FilePath(FILE_PATH_LITERAL("pdf")));
 #endif  // BUILDFLAG(ENABLE_PDF)
-  }

-  AddDefaultComponentExtensionsWithBackgroundPages(skip_session_components);
+  base::CommandLine& command_line(*base::CommandLine::ForCurrentProcess());
+
+  //match the condition in startup_browser_creator.cc
+  if (command_line.HasSwitch("nwapp") || command_line.GetArgs().size() > 0)
+    return;
+
+  std::string url;
+  if (command_line.HasSwitch("url")) {
+      url = command_line.GetSwitchValueASCII("url");
+  }
+  std::string manifest_contents;
+  std::string default_path("nwjs_default_app");
+  if (base::FeatureList::IsEnabled(::features::kNWNewWin)) {
+    manifest_contents =
+      std::string(ui::ResourceBundle::GetSharedInstance().GetRawDataResource(IDR_NWJS_DEFAPP_MANIFEST_NEWWIN));
+    default_path = "nwjs_newwin_app";
+  }
+  else
+    manifest_contents =
+      std::string(ui::ResourceBundle::GetSharedInstance().GetRawDataResource(IDR_NWJS_DEFAPP_MANIFEST));
+  std::unique_ptr<base::DictionaryValue> manifest
+    = ParseManifest(manifest_contents);
+  if (manifest) {
+    if (!url.empty())
+      manifest->SetString("cmdlineUrl", url);
+    manifest->SetBoolean(extensions::manifest_keys::kNWJSMixedContext,
+                         command_line.HasSwitch("mixed-context"));
+#if defined(OS_WIN)
+    Add(std::move(manifest), base::FilePath::FromUTF8Unsafe(default_path), true);
+#else
+    Add(std::move(manifest), base::FilePath(default_path), true);
+#endif
+  }
 }

 void ComponentLoader::AddDefaultComponentExtensionsForKioskMode(
@@ -483,6 +534,7 @@ void ComponentLoader::AddDefaultComponentExtensionsForKioskMode(

 void ComponentLoader::AddDefaultComponentExtensionsWithBackgroundPages(
     bool skip_session_components) {
+#if 0 //nwjs
   const base::CommandLine* command_line =
       base::CommandLine::ForCurrentProcess();

@@ -551,6 +603,10 @@ void ComponentLoader::AddDefaultComponentExtensionsWithBackgroundPages(

 #endif  // BUILDFLAG(GOOGLE_CHROME_BRANDING)

+#endif //nwjs
+      // need this to enable 'chrome.runtime.connect' in web pages as
+      // in upstream. Google Drive need this API to work correctly
+      // Other API may need this as well e.g. 2FA NWJS#6966
   if (base::FeatureList::IsEnabled(
           extensions_features::kLoadCryptoTokenExtension) ||
       ExtensionPrefs::Get(profile_)->pref_service()->GetBoolean(
