diff --git a/chrome/browser/ui/cocoa/apps/app_shim_menu_controller_mac.mm b/chrome/browser/ui/cocoa/apps/app_shim_menu_controller_mac.mm
index 4806ee2efa..25636f57cb 100644
--- a/chrome/browser/ui/cocoa/apps/app_shim_menu_controller_mac.mm
+++ b/chrome/browser/ui/cocoa/apps/app_shim_menu_controller_mac.mm
@@ -2,6 +2,10 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.

+#include "base/command_line.h"
+#include "chrome/browser/lifetime/application_lifetime.h"
+#include "content/public/common/content_features.h"
+
 #import "chrome/browser/ui/cocoa/apps/app_shim_menu_controller_mac.h"

 #include "base/containers/adapters.h"
@@ -27,6 +31,11 @@
 using extensions::Extension;
 using extensions::ExtensionRegistry;

+#include "chrome/browser/devtools/devtools_window.h"
+
+#include "content/nw/src/api/menu/menu.h"
+#include "content/nw/src/common/shell_switches.h"
+
 namespace {

 // Gets an item from the main menu given the tag of the top level item
@@ -62,6 +71,7 @@ void AddDuplicateItem(NSMenuItem* top_level_item,
   [[top_level_item submenu] addItem:item];
 }

+#if 0
 // Finds an item with |item_tag| and removes it from the submenu of
 // |top_level_item|.
 void RemoveMenuItemWithTag(NSMenuItem* top_level_item,
@@ -119,6 +129,7 @@ void SetItemWithTagVisible(NSMenuItem* top_level_item,
   [alternate_item setHidden:!visible];
   [menu_item setHidden:!visible];
 }
+#endif

 // Retrieve the Extension and (optionally) Profile for an NSWindow.
 const Extension* GetExtensionForNSWindow(NSWindow* window,
@@ -285,6 +296,7 @@ extensions::AppWindowRegistry::AppWindowList GetAppWindowsForNSWindow(
 - (void)hideCurrentPlatformApp;
 // If the currently focused window belongs to a platform app, focus the app.
 - (void)focusCurrentPlatformApp;
+- (void)showDevtools;
 @end

 @implementation AppShimMenuController
@@ -324,6 +336,7 @@ extensions::AppWindowRegistry::AppWindowList GetAppWindowsForNSWindow(
               resourceId:IDS_EXIT_MAC
                   action:@selector(quitCurrentPlatformApp)
            keyEquivalent:@"q"]);
+#if 0
   _newDoppelganger.reset([[DoppelgangerMenuItem alloc]
       initWithController:self
                  menuTag:IDC_FILE_MENU
@@ -348,6 +361,7 @@ extensions::AppWindowRegistry::AppWindowList GetAppWindowsForNSWindow(
               resourceId:0
                   action:nil
            keyEquivalent:@"o"]);
+#endif
   _allToFrontDoppelganger.reset([[DoppelgangerMenuItem alloc]
       initWithController:self
                  menuTag:IDC_WINDOW_MENU
@@ -371,18 +385,21 @@ extensions::AppWindowRegistry::AppWindowList GetAppWindowsForNSWindow(
   [appMenu addItem:[NSMenuItem separatorItem]];
   [appMenu addItem:[_quitDoppelganger menuItem]];

+#if 0
   // File menu.
   _fileMenuItem.reset([NewTopLevelItemFrom(IDC_FILE_MENU) retain]);
   [[_fileMenuItem submenu] addItem:[_newDoppelganger menuItem]];
   [[_fileMenuItem submenu] addItem:[_openDoppelganger menuItem]];
   [[_fileMenuItem submenu] addItem:[NSMenuItem separatorItem]];
   [[_fileMenuItem submenu] addItem:[_closeWindowDoppelganger menuItem]];
+#endif

   // Edit menu. We copy the menu because the last two items, "Start Dictation"
   // and "Special Characters" are added by OSX, so we can't copy them
   // explicitly.
   _editMenuItem.reset([[[NSApp mainMenu] itemWithTag:IDC_EDIT_MENU] copy]);

+#if 0
   // View menu. Remove "Always Show Bookmark Bar" and separator.
   _viewMenuItem.reset([[[NSApp mainMenu] itemWithTag:IDC_VIEW_MENU] copy]);
   RemoveMenuItemWithTag(_viewMenuItem, IDC_SHOW_BOOKMARK_BAR, YES);
@@ -392,12 +409,34 @@ extensions::AppWindowRegistry::AppWindowList GetAppWindowsForNSWindow(
   AddDuplicateItem(_historyMenuItem, IDC_HISTORY_MENU, IDC_BACK);
   AddDuplicateItem(_historyMenuItem, IDC_HISTORY_MENU, IDC_FORWARD);

+#endif
   // Window menu.
   _windowMenuItem.reset([NewTopLevelItemFrom(IDC_WINDOW_MENU) retain]);
   AddDuplicateItem(_windowMenuItem, IDC_WINDOW_MENU, IDC_MINIMIZE_WINDOW);
   AddDuplicateItem(_windowMenuItem, IDC_WINDOW_MENU, IDC_MAXIMIZE_WINDOW);
   [[_windowMenuItem submenu] addItem:[NSMenuItem separatorItem]];
   [[_windowMenuItem submenu] addItem:[_allToFrontDoppelganger menuItem]];
+
+#if defined(NWJS_SDK)
+  bool enable_devtools = true;
+  const base::CommandLine* command_line =
+      base::CommandLine::ForCurrentProcess();
+  if (command_line->HasSwitch(switches::kDisableDevTools))
+    enable_devtools = false;
+
+  if (enable_devtools) {
+  [[_windowMenuItem submenu] setAutoenablesItems:NO];
+  NSMenuItem* item = [[NSMenuItem alloc]
+		      initWithTitle:@"Devtools"
+		      action:@selector(showDevtools)
+                      keyEquivalent:@"i"];
+  [item setTag:IDC_DEV_TOOLS_CONSOLE];
+  [item setTarget:self];
+  [item setEnabled:YES];
+  [item setKeyEquivalentModifierMask:NSEventModifierFlagCommand | NSEventModifierFlagOption];
+  [[_windowMenuItem submenu] addItem:item];
+  }
+#endif
 }

 - (void)registerEventHandlers {
@@ -428,8 +467,20 @@ extensions::AppWindowRegistry::AppWindowList GetAppWindowsForNSWindow(
     // Ignore is_browser: if a window becomes main that does not belong to an
     // extension or browser, treat it the same as switching to a browser.
     const Extension* extension = GetExtensionForNSWindow(window);
-    if (extension)
-      [self appBecameMain:extension];
+    extensions::AppWindow* appWindow =
+      AppWindowRegistryUtil::GetAppWindowForNativeWindowAnyProfile(window);
+    if (extension) {
+        if (appWindow && appWindow->menu_) {
+            [NSApp setMainMenu:appWindow->menu_->menu_];
+            return;
+        }
+        Browser* browser = chrome::FindBrowserWithWindow(window);
+        if (browser && browser->nw_menu_) {
+          [NSApp setMainMenu:browser->nw_menu_->menu_];
+          return;
+        }
+        [self appBecameMain:extension];
+    }
     else
       [self chromeBecameMain];
   } else if ([name isEqualToString:NSWindowDidResignMainNotification]) {
@@ -460,18 +511,25 @@ extensions::AppWindowRegistry::AppWindowList GetAppWindowsForNSWindow(
     return;

   if (!_appId.empty())
-    [self removeMenuItems];
+      return;
+  // #4591: when app sets menubar and launch another chrome app,
+  // removeMenuItems will try to remove appmenuitem which isn't
+  // in the main menu; then app will crash.
+  // so after this function runs once, we just do nothing and return here
+  //  [self removeMenuItems];

   _appId = app->id();
   [self addMenuItems:app];
 }

 - (void)chromeBecameMain {
+#if 0
   if (_appId.empty())
     return;

   _appId.clear();
   [self removeMenuItems];
+#endif
 }

 - (void)addMenuItems:(const Extension*)app {
@@ -486,14 +544,15 @@ extensions::AppWindowRegistry::AppWindowList GetAppWindowsForNSWindow(
   [_aboutDoppelganger enableForApp:app];
   [_hideDoppelganger enableForApp:app];
   [_quitDoppelganger enableForApp:app];
-  [_newDoppelganger enableForApp:app];
-  [_openDoppelganger enableForApp:app];
-  [_closeWindowDoppelganger enableForApp:app];
+  //[_newDoppelganger enableForApp:app];
+  //[_openDoppelganger enableForApp:app];
+  //[_closeWindowDoppelganger enableForApp:app];

   [_appMenuItem setTitle:base::SysUTF8ToNSString(_appId)];
   [[_appMenuItem submenu] setTitle:title];

   [mainMenu addItem:_appMenuItem];
+#if 0
   [mainMenu addItem:_fileMenuItem];

   SetItemWithTagVisible(_editMenuItem,
@@ -501,24 +560,32 @@ extensions::AppWindowRegistry::AppWindowList GetAppWindowsForNSWindow(
                         app->is_hosted_app(), true);
   SetItemWithTagVisible(_editMenuItem, IDC_FIND_MENU, app->is_hosted_app(),
                         false);
+#endif
   [mainMenu addItem:_editMenuItem];

+#if 0
   if (app->is_hosted_app()) {
     [mainMenu addItem:_viewMenuItem];
     [mainMenu addItem:_historyMenuItem];
   }
+#endif
   [mainMenu addItem:_windowMenuItem];
 }

 - (void)removeMenuItems {
   NSMenu* mainMenu = [NSApp mainMenu];
+  if ([mainMenu indexOfItem:_appMenuItem] >= 0)
   [mainMenu removeItem:_appMenuItem];
-  [mainMenu removeItem:_fileMenuItem];
+  //[mainMenu removeItem:_fileMenuItem];
+#if 0
   if ([mainMenu indexOfItem:_viewMenuItem] >= 0)
     [mainMenu removeItem:_viewMenuItem];
   if ([mainMenu indexOfItem:_historyMenuItem] >= 0)
     [mainMenu removeItem:_historyMenuItem];
+#endif
+  if ([mainMenu indexOfItem:_editMenuItem] >= 0)
   [mainMenu removeItem:_editMenuItem];
+  if ([mainMenu indexOfItem:_windowMenuItem] >= 0)
   [mainMenu removeItem:_windowMenuItem];

   // Restore the Chrome main menu bar.
@@ -528,15 +595,22 @@ extensions::AppWindowRegistry::AppWindowList GetAppWindowsForNSWindow(
   [_aboutDoppelganger disable];
   [_hideDoppelganger disable];
   [_quitDoppelganger disable];
-  [_newDoppelganger disable];
-  [_openDoppelganger disable];
-  [_closeWindowDoppelganger disable];
+  //[_newDoppelganger disable];
+  //[_openDoppelganger disable];
+  //[_closeWindowDoppelganger disable];
 }

 - (void)quitCurrentPlatformApp {
+  if (base::FeatureList::IsEnabled(::features::kNWNewWin)) {
+    chrome::CloseAllBrowsers(false, true);
+    return;
+  }
+
   auto windows = GetAppWindowsForNSWindow([NSApp keyWindow]);
-  for (extensions::AppWindow* window : base::Reversed(windows))
-    window->GetBaseWindow()->Close();
+  for (extensions::AppWindow* window : base::Reversed(windows)) {
+    if (window->NWCanClose(true))
+      window->GetBaseWindow()->Close();
+  }
 }

 - (void)hideCurrentPlatformApp {
@@ -551,4 +625,12 @@ extensions::AppWindowRegistry::AppWindowList GetAppWindowsForNSWindow(
     window->GetBaseWindow()->Show();
 }

+- (void)showDevtools {
+  extensions::AppWindow* appWindow =
+      AppWindowRegistryUtil::GetAppWindowForNativeWindowAnyProfile(
+          [NSApp keyWindow]);
+  if (appWindow)
+    DevToolsWindow::OpenDevToolsWindow(appWindow->web_contents());
+}
+
 @end
