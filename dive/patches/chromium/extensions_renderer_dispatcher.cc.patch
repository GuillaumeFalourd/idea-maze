diff --git a/extensions/renderer/dispatcher.cc b/extensions/renderer/dispatcher.cc
index f8f60f1c82..ab1925de69 100644
--- a/extensions/renderer/dispatcher.cc
+++ b/extensions/renderer/dispatcher.cc
@@ -10,6 +10,8 @@
 #include <memory>
 #include <utility>

+#include "base/command_line.h"
+
 #include "base/bind.h"
 #include "base/callback.h"
 #include "base/callback_helpers.h"
@@ -122,12 +124,40 @@
 #include "v8/include/v8-object.h"
 #include "v8/include/v8-primitive.h"

+#include "base/files/file_util.h"
+//#include "content/common/dom_storage/dom_storage_map.h"
+#include "content/nw/src/nw_content.h"
+#include "content/nw/src/nw_custom_bindings.h"
+#include "third_party/node-nw/src/node_webkit.h"
+
+#if defined(COMPONENT_BUILD) && defined(WIN32)
+#define NW_HOOK_MAP(type, sym, fn) CONTENT_EXPORT type fn;
+#else
+#define NW_HOOK_MAP(type, sym, fn) extern type fn;
+#endif
+#include "content/nw/src/common/node_hooks.h"
+#undef NW_HOOK_MAP
+
+#if defined(COMPONENT_BUILD) && defined(WIN32)
+BLINK_EXPORT int g_nw_dom_storage_quota;
+#else
+extern int g_nw_dom_storage_quota;
+#endif
+
 using blink::WebDocument;
 using blink::WebSecurityPolicy;
 using blink::WebString;
 using blink::WebView;
 using content::RenderThread;

+namespace content {
+#if defined(COMPONENT_BUILD) && defined(WIN32)
+CONTENT_EXPORT base::FilePath g_nw_temp_dir, g_nw_old_cwd;
+#else
+extern base::FilePath g_nw_temp_dir, g_nw_old_cwd;
+#endif
+}
+
 namespace extensions {

 namespace {
@@ -253,6 +283,12 @@ scoped_refptr<Extension> ConvertToExtension(
   return extension;
 }

+int nw_uv_run(void* loop, int mode) {
+  v8::MicrotasksScope microtasks(v8::Isolate::GetCurrent(), v8::MicrotasksScope::kDoNotRunMicrotasks);
+
+  return g_uv_run_fn(loop, mode);
+}
+
 }  // namespace

 Dispatcher::PendingServiceWorker::PendingServiceWorker(
@@ -327,6 +363,8 @@ Dispatcher::Dispatcher(std::unique_ptr<DispatcherDelegate> delegate)

   WebSecurityPolicy::RegisterURLSchemeAsAllowingWasmEvalCSP(extension_scheme);

+  g_set_uv_run_fn(nw_uv_run);
+
   // Initialize host permissions for any extensions that were activated before
   // WebKit was initialized.
   for (const std::string& extension_id : active_extension_ids_) {
@@ -397,8 +435,26 @@ void Dispatcher::DidCreateScriptContext(

   bindings_system_->DidCreateScriptContext(context);

+  bool run_nw_hook = false;
+  if (context->extension()) {
+    if (context->extension()->GetType() == Manifest::TYPE_NWJS_APP &&
+        context->context_type() == Feature::BLESSED_EXTENSION_CONTEXT) {
+      run_nw_hook = true;
+    }
+  }
+  if (!run_nw_hook) {
+    const base::CommandLine& command_line =
+      *base::CommandLine::ForCurrentProcess();
+    if (command_line.HasSwitch("nwjs-guest-nw"))
+      run_nw_hook = true;
+  }
+  DVLOG(1) << "run_nw_hook: " << run_nw_hook;
+  if (run_nw_hook)
+    nw::ContextCreationHook(frame, context);
+
   // Inject custom JS into the platform app context.
-  if (IsWithinPlatformApp()) {
+  if (IsWithinPlatformApp() && context->extension() &&
+      context->extension()->GetType() != Manifest::TYPE_NWJS_APP) {
     module_system->Require("platformApp");
   }

@@ -573,8 +629,7 @@ void Dispatcher::WillEvaluateServiceWorkerOnWorkerThread(

     // TODO(lazyboy): Get rid of RequireGuestViewModules() as this doesn't seem
     // necessary for Extension SW.
-    RequireGuestViewModules(context);
-
+    //RequireGuestViewModules(context); //NWJS#6624
     worker_dispatcher->DidInitializeContext(service_worker_version_id);
   }

@@ -642,6 +697,15 @@ void Dispatcher::WillReleaseScriptContext(
   ScriptContext* context = script_context_set_->GetByV8Context(v8_context);
   if (!context)
     return;
+
+  //FIXME: upstream removed unload_event: we should check our event
+  //f66545e9e5d0308c15f51764e311425894e3ad09
+
+  if (context && context->extension() &&
+      context->extension()->is_nwjs_app() &&
+      script_context_set_->size() == 1) {
+    nw::OnRenderProcessShutdownHook(context);
+  }
   bindings_system_->WillReleaseScriptContext(context);

   script_context_set_->Remove(context);
@@ -699,6 +763,16 @@ void Dispatcher::WillDestroyServiceWorkerContextOnWorkerThread(
   }
 }

+void Dispatcher::DidDispatchDOMContentLoadedEvent(blink::WebLocalFrame* frame) {
+  GURL effective_document_url = ScriptContext::GetEffectiveDocumentURLForContext(
+      frame, frame->GetDocument().Url(), true /* match_about_blank */);
+
+  const Extension* extension =
+    RendererExtensionRegistry::Get()->GetExtensionOrAppByURL(effective_document_url);
+
+  nw::DocumentFinishHook(frame, extension, effective_document_url);
+}
+
 void Dispatcher::DidCreateDocumentElement(blink::WebLocalFrame* frame) {
   // Note: use GetEffectiveDocumentURLForContext() and not just
   // frame->document()->url() so that this also injects the stylesheet on
@@ -717,6 +791,11 @@ void Dispatcher::DidCreateDocumentElement(blink::WebLocalFrame* frame) {

   if (extension &&
       (extension->is_extension() || extension->is_platform_app())) {
+    nw::DocumentElementHook(frame, extension, effective_document_url);
+  }
+
+  if (extension && !extension->is_nwjs_app() &&
+      (extension->is_extension() || extension->is_platform_app())) {
     int resource_id = extension->is_platform_app() ? IDR_PLATFORM_APP_CSS
                                                    : IDR_EXTENSION_FONTS_CSS;
     std::string stylesheet =
@@ -790,7 +869,13 @@ void Dispatcher::InvokeModuleSystemMethod(content::RenderFrame* render_frame,
                                           const std::string& module_name,
                                           const std::string& function_name,
                                           const base::Value::List& args) {
-  script_context_set_->ForEach(
+  // need extension id set to empty for remote pages
+  if (render_frame && (module_name == "nw.Window" || module_name == "app.window"))
+    script_context_set_->ForEach(
+      "", render_frame,
+      base::BindRepeating(&CallModuleMethod, module_name, function_name, &args));
+  else
+    script_context_set_->ForEach(
       extension_id, render_frame,
       base::BindRepeating(&CallModuleMethod, module_name, function_name,
                           &args));
@@ -890,6 +975,23 @@ std::vector<Dispatcher::JsResourceInfo> Dispatcher::GetJsResources() {
       {"platformApp", IDR_PLATFORM_APP_JS},
   };

+  if (base::FeatureList::IsEnabled(::features::kNWNewWin))
+    resources.push_back({"nw.Window",    IDR_NWAPI_NEWWIN_JS});
+  else {
+    resources.push_back({"nw.Window",    IDR_NWAPI_WINDOW_JS});
+  }
+  resources.push_back({"nw.currentWindowInternal",    IDR_NWAPI_WINDOW_INTERNAL_JS});
+
+  resources.push_back({"nw.App",       IDR_NWAPI_APP_JS});
+  resources.push_back({"nw.Clipboard", IDR_NWAPI_CLIPBOARD_JS});
+  resources.push_back({"nw.Menu",      IDR_NWAPI_MENU_JS});
+  resources.push_back({"nw.MenuItem",  IDR_NWAPI_MENUITEM_JS});
+  resources.push_back({"nw.Screen",    IDR_NWAPI_SCREEN_JS});
+  resources.push_back({"nw.Shell",     IDR_NWAPI_SHELL_JS});
+  resources.push_back({"nw.Shortcut",  IDR_NWAPI_SHORTCUT_JS});
+  resources.push_back({"nw.Obj",       IDR_NWAPI_OBJECT_JS});
+  resources.push_back({"nw.test",      IDR_NWAPI_TEST_JS});
+  resources.push_back({"nw.Tray",      IDR_NWAPI_TRAY_JS});
   return resources;
 }

@@ -946,6 +1048,8 @@ void Dispatcher::RegisterNativeHandlers(
       std::make_unique<ServiceWorkerNatives>(context));

   // Custom bindings.
+  module_system->RegisterNativeHandler(
+      "nw_natives", std::unique_ptr<NativeHandler>(new NWCustomBindings(context)));
   module_system->RegisterNativeHandler(
       "app_window_natives",
       std::unique_ptr<NativeHandler>(new AppWindowCustomBindings(context)));
@@ -1113,6 +1217,29 @@ void Dispatcher::LoadExtensions(
                            base::Unretained(this), extension->id()));
       }
     }
+    if (extension->GetType() == Manifest::TYPE_NWJS_APP) {
+      const std::string* user_agent;
+      if ((user_agent = extension->manifest()->FindStringPath("user-agent"))) {
+        const std::string* name, *version;
+        name = extension->manifest()->FindStringPath("name");
+        version = extension->manifest()->FindStringPath("version");
+        if (name && version)
+          nw::SetUserAgentOverride(*user_agent, *name, *version);
+      }
+
+      const base::Value* quota_value = extension->manifest()->available_values().FindKey("dom_storage_quota");
+      if (quota_value && quota_value->is_int()) {
+        //content::DOMStorageMap::SetQuotaOverride(dom_storage_quota_mb * 1024 * 1024);
+        g_nw_dom_storage_quota = quota_value->GetInt() * 1024 * 1024;
+      }
+      const std::string* temp_path;
+      if ((temp_path = extension->manifest()->FindStringPath("nw-temp-dir"))) {
+        content::g_nw_temp_dir = base::FilePath::FromUTF8Unsafe(*temp_path);
+      }
+      VLOG(1) << "NW: change working dir: " << extension->path().AsUTF8Unsafe();
+      base::GetCurrentDirectory(&content::g_nw_old_cwd);
+      base::SetCurrentDirectory(extension->path());
+    }
   }

   // Update the available bindings for all contexts. These may have changed if
