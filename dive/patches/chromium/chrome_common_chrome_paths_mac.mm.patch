diff --git a/chrome/common/chrome_paths_mac.mm b/chrome/common/chrome_paths_mac.mm
index 41538c647a..b99a8e5bd8 100644
--- a/chrome/common/chrome_paths_mac.mm
+++ b/chrome/common/chrome_paths_mac.mm
@@ -19,6 +19,8 @@
 #include "chrome/common/chrome_constants.h"
 #include "chrome/common/chrome_paths_internal.h"

+#include "content/nw/src/nw_base.h"
+
 namespace {

 // Return a retained (NOT autoreleased) NSBundle* as the internal
@@ -59,7 +61,7 @@ char* ProductDirNameForBundle(NSBundle* chrome_bundle) {
 #if BUILDFLAG(GOOGLE_CHROME_BRANDING)
       product_dir_name = "Google/Chrome";
 #else
-      product_dir_name = "Chromium";
+    product_dir_name = "nwjs";
 #endif
     }

@@ -69,6 +71,7 @@ char* ProductDirNameForBundle(NSBundle* chrome_bundle) {
   }
 }

+#if 0
 // ProductDirName returns the name of the directory inside
 // ~/Library/Application Support that should hold the product application
 // data. This can be overridden by setting the CrProductDirName key in the
@@ -90,6 +93,7 @@ std::string ProductDirName() {
       ProductDirNameForBundle(chrome::OuterAppBundle());
   return std::string(product_dir_name);
 }
+#endif

 bool GetDefaultUserDataDirectoryForProduct(const std::string& product_dir,
                                            base::FilePath* result) {
@@ -106,7 +110,7 @@ bool GetDefaultUserDataDirectoryForProduct(const std::string& product_dir,
 namespace chrome {

 bool GetDefaultUserDataDirectory(base::FilePath* result) {
-  return GetDefaultUserDataDirectoryForProduct(ProductDirName(), result);
+  return GetDefaultUserDataDirectoryForProduct(nw::package()->GetName(), result);
 }

 bool GetUserDocumentsDirectory(base::FilePath* result) {
