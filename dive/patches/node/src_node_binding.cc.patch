diff --git a/src/node_binding.cc b/src/node_binding.cc
index 06af1841..c685ae9d 100644
--- a/src/node_binding.cc
+++ b/src/node_binding.cc
@@ -1,3 +1,4 @@
+#include "uv.h"
 #include "node_binding.h"
 #include <atomic>
 #include "env-inl.h"
@@ -249,21 +250,40 @@ static node_module* modlist_internal;
 static node_module* modlist_linked;
 static thread_local node_module* thread_local_modpending;
 
+uv_key_t thread_ctx_key;
+int thread_ctx_created = 0;
+int g_worker_support = 0;
+
 // This is set by node::Init() which is used by embedders
 bool node_is_initialized = false;
 
 extern "C" void node_module_register(void* m) {
-  struct node_module* mp = reinterpret_cast<struct node_module*>(m);
+  struct node_module* mp;
+  if (g_worker_support) {
+    mp = (struct node_module*)malloc(sizeof(struct node_module));
+    memcpy(mp, m, sizeof(struct node_module));
+  } else
+    mp = reinterpret_cast<struct node_module*>(m);
+  if (!thread_ctx_created) {
+    thread_ctx_created = 1;
+    uv_key_create(&thread_ctx_key);
+  }
+  thread_ctx_st* tls_ctx = (struct thread_ctx_st*)uv_key_get(&thread_ctx_key);
+  if (!tls_ctx) {
+    tls_ctx = (struct thread_ctx_st*)malloc(sizeof(struct thread_ctx_st));
+    memset(tls_ctx, 0, sizeof(struct thread_ctx_st));
+    uv_key_set(&thread_ctx_key, tls_ctx);
+  }
 
   if (mp->nm_flags & NM_F_INTERNAL) {
-    mp->nm_link = modlist_internal;
-    modlist_internal = mp;
+    mp->nm_link = tls_ctx->modlist_internal;
+    tls_ctx->modlist_internal = mp;
   } else if (!node_is_initialized) {
     // "Linked" modules are included as part of the node project.
     // Like builtins they are registered *before* node::Init runs.
     mp->nm_flags = NM_F_LINKED;
-    mp->nm_link = modlist_linked;
-    modlist_linked = mp;
+    mp->nm_link = tls_ctx->modlist_linked;
+    tls_ctx->modlist_linked = mp;
   } else {
     thread_local_modpending = mp;
   }
@@ -426,6 +446,7 @@ void DLOpen(const FunctionCallbackInfo<Value>& args) {
   auto context = env->context();
 
   CHECK_NULL(thread_local_modpending);
+  thread_ctx_st* tls_ctx = (struct thread_ctx_st*)uv_key_get(&thread_ctx_key);
 
   if (args.Length() < 2) {
     return THROW_ERR_MISSING_ARGS(
@@ -489,7 +510,9 @@ void DLOpen(const FunctionCallbackInfo<Value>& args) {
         return true;
       } else {
         mp = dlib->GetSavedModuleFromGlobalHandleMap();
-        if (mp == nullptr || mp->nm_context_register_func == nullptr) {
+        //NWJS: the checking of context aware module is not needed
+        //since this is supported in NW worker
+        if (mp == nullptr) { // || mp->nm_context_register_func == nullptr) {
           dlib->Close();
           THROW_ERR_DLOPEN_FAILED(
               env, "Module did not self-register: '%s'.", *filename);
@@ -529,6 +552,7 @@ void DLOpen(const FunctionCallbackInfo<Value>& args) {
 
     // Do not keep the lock while running userland addon loading code.
     Mutex::ScopedUnlock unlock(lock);
+
     if (mp->nm_context_register_func != nullptr) {
       mp->nm_context_register_func(exports, module, context, mp->nm_priv);
     } else if (mp->nm_register_func != nullptr) {
@@ -583,7 +607,8 @@ void GetInternalBinding(const FunctionCallbackInfo<Value>& args) {
   node::Utf8Value module_v(env->isolate(), module);
   Local<Object> exports;
 
-  node_module* mod = FindModule(modlist_internal, *module_v, NM_F_INTERNAL);
+  thread_ctx_st* tls_ctx = (struct thread_ctx_st*)uv_key_get(&thread_ctx_key);
+  node_module* mod = FindModule(tls_ctx->modlist_internal, *module_v, NM_F_INTERNAL);
   if (mod != nullptr) {
     exports = InitModule(env, mod, module);
     env->internal_bindings.insert(mod);
