diff --git a/src/node_contextify.cc b/src/node_contextify.cc
index 6c7412c1..8d3d5437 100644
--- a/src/node_contextify.cc
+++ b/src/node_contextify.cc
@@ -33,6 +33,7 @@
 #include "util-inl.h"
 
 namespace node {
+extern bool node_is_nwjs;
 namespace contextify {
 
 using errors::TryCatchScope;
@@ -245,6 +246,11 @@ bool ContextifyContext::InitializeContext(Local<Context> ctx,
   // directly in an Object, we instead hold onto the new context's global
   // object instead (which then has a reference to the context).
   ctx->SetEmbedderData(ContextEmbedderIndex::kSandboxObject, sandbox_obj);
+  if (node_is_nwjs) {
+    void* data = env->context()->GetAlignedPointerFromEmbedderData(2); //v8ContextPerContextDataIndex
+    ctx->SetAlignedPointerInEmbedderData(2, data);
+    ctx->SetAlignedPointerInEmbedderData(50, (void*)0x08110800);
+  }
   sandbox_obj->SetPrivate(
       main_context, env->contextify_global_private_symbol(), ctx->Global());
 
@@ -769,6 +775,7 @@ void ContextifyScript::New(const FunctionCallbackInfo<Value>& args) {
   ContextifyScript* contextify_script =
       new ContextifyScript(env, args.This());
 
+#if 0
   if (*TRACE_EVENT_API_GET_CATEGORY_GROUP_ENABLED(
           TRACING_CATEGORY_NODE2(vm, script)) != 0) {
     Utf8Value fn(isolate, filename);
@@ -777,6 +784,7 @@ void ContextifyScript::New(const FunctionCallbackInfo<Value>& args) {
                        "filename",
                        TRACE_STR_COPY(*fn));
   }
+#endif
 
   ScriptCompiler::CachedData* cached_data = nullptr;
   if (!cached_data_buf.IsEmpty()) {
