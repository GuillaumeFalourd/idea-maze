diff --git a/src/node_errors.cc b/src/node_errors.cc
index 323fc7d4..fd9f198e 100644
--- a/src/node_errors.cc
+++ b/src/node_errors.cc
@@ -34,6 +34,8 @@ using v8::String;
 using v8::Undefined;
 using v8::Value;
 
+extern bool node_is_nwjs;
+
 bool IsExceptionDecorated(Environment* env, Local<Value> er) {
   if (!er.IsEmpty() && er->IsObject()) {
     Local<Object> err_obj = er.As<Object>();
@@ -495,10 +497,10 @@ void OnFatalError(const char* location, const char* message) {
   ABORT();
 }
 
-void OOMErrorHandler(const char* location, bool is_heap_oom) {
+void OOMErrorHandler(const char* location, const v8::OOMDetails& details) {
   const char* message =
-      is_heap_oom ? "Allocation failed - JavaScript heap out of memory"
-                  : "Allocation failed - process out of memory";
+      details.is_heap_oom ? "Allocation failed - JavaScript heap out of memory"
+                          : "Allocation failed - process out of memory";
   if (location) {
     FPrintF(stderr, "FATAL ERROR: %s %s\n", location, message);
   } else {
@@ -1076,8 +1078,9 @@ void TriggerUncaughtException(Isolate* isolate,
     // error is supposed to be thrown at this point.
     // Since we don't have access to Environment here, there is not
     // much we can do, so we just print whatever is useful and crash.
-    PrintException(isolate, context, error, message);
-    Abort();
+    //PrintException(isolate, context, error, message);
+    //Abort();
+    return;
   }
 
   // Invoke process._fatalException() to give user a chance to handle it.
@@ -1085,16 +1088,17 @@ void TriggerUncaughtException(Isolate* isolate,
   // monkey-patchable.
   Local<Object> process_object = env->process_object();
   Local<String> fatal_exception_string = env->fatal_exception_string();
-  Local<Value> fatal_exception_function =
+  Local<Value> fatal_exception_function_value =
       process_object->Get(env->context(),
                           fatal_exception_string).ToLocalChecked();
   // If the exception happens before process._fatalException is attached
   // during bootstrap, or if the user has patched it incorrectly, exit
   // the current Node.js instance.
-  if (!fatal_exception_function->IsFunction()) {
+  int exit_code = 0;
+  if (!fatal_exception_function_value->IsFunction()) {
     ReportFatalException(
         env, error, message, EnhanceFatalException::kDontEnhance);
-    env->Exit(6);
+    exit_code = 6;
     return;
   }
 
@@ -1112,7 +1116,7 @@ void TriggerUncaughtException(Isolate* isolate,
     Local<Value> argv[2] = { error,
                              Boolean::New(env->isolate(), from_promise) };
 
-    maybe_handled = fatal_exception_function.As<Function>()->Call(
+    maybe_handled = fatal_exception_function_value.As<Function>()->Call(
         env->context(), process_object, arraysize(argv), argv);
   }
 
@@ -1141,13 +1145,16 @@ void TriggerUncaughtException(Isolate* isolate,
 
   // If the global uncaught exception handler sets process.exitCode,
   // exit with that code. Otherwise, exit with 1.
-  Local<String> exit_code = env->exit_code_string();
+  Local<String> exit_code_val = env->exit_code_string();
   Local<Value> code;
-  if (process_object->Get(env->context(), exit_code).ToLocal(&code) &&
+  if (process_object->Get(env->context(), exit_code_val).ToLocal(&code) &&
       code->IsInt32()) {
-    env->Exit(code.As<Int32>()->Value());
+    exit_code = (code.As<Int32>()->Value());
   } else {
-    env->Exit(1);
+    exit_code = 1;
+  }
+  if (!node_is_nwjs && exit_code) {
+    exit(exit_code);
   }
 }
 
